<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω—ã–π —Å–∫—Ä–µ–º–±–ª–µ—Ä - –ü–æ–ª–Ω–∞—è –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å</title>
    <style>
        body { font-family: 'Courier New', monospace; margin: 20px; background: #f0f0f0; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h2 { color: #2c3e50; text-align: center; margin-bottom: 20px; }
        .panel { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #3498db; }
        .input-group { margin-bottom: 12px; display: flex; align-items: center; }
        label { display: inline-block; width: 150px; font-weight: bold; color: #2c3e50; }
        input[type="text"], input[type="number"] { 
            width: 120px; padding: 8px; border: 2px solid #ddd; border-radius: 4px; 
            font-family: monospace; font-size: 14px;
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: #3498db; outline: none;
        }
        button { 
            padding: 10px 20px; margin: 5px; cursor: pointer; background: #3498db; color: white; 
            border: none; border-radius: 5px; font-weight: bold; transition: background 0.3s;
        }
        button:hover { background: #2980b9; }
        button:active { transform: translateY(1px); }
        .result { margin-top: 20px; padding: 15px; border: 2px solid #e74c3c; border-radius: 5px; background: #fff5f5; }
        .success { border-color: #27ae60; background: #f0fff4; }
        .status { font-weight: bold; padding: 8px; border-radius: 4px; margin-bottom: 10px; }
        .status.ready { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.waiting { background: #fff3cd; color: #856404; }
        .coordinates { 
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;
            font-family: monospace; font-size: 16px;
        }
        .coord-item { padding: 5px; background: #f8f9fa; border-radius: 3px; }
        .test-results { margin-top: 15px; padding: 10px; background: #e8f4f8; border-radius: 5px; }
        .test-item { margin: 5px 0; padding: 3px; }
        .test-pass { color: #27ae60; }
        .test-fail { color: #e74c3c; }
        .hex { color: #7d3c98; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h2>üîê –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–Ω—ã–π —Å–∫—Ä–µ–º–±–ª–µ—Ä - –ü–æ–ª–Ω–∞—è –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å</h2>
        
        <div class="panel">
            <h3>üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–ª—é—á–∞</h3>
            <div class="input-group">
                <label for="passphrase">–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞:</label>
                <input type="text" id="passphrase" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á 123" placeholder="–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å">
            </div>
            
            <div class="input-group">
                <label for="salt">–°–æ–ª—å (hex):</label>
                <input type="text" id="salt" value="a1b2c3d4e5f67890" placeholder="a1b2c3d4...">
            </div>
            
            <div class="input-group">
                <label for="iterations">–ò—Ç–µ—Ä–∞—Ü–∏–∏ PBKDF2:</label>
                <input type="number" id="iterations" value="100000" min="1000" max="1000000">
            </div>
        </div>

        <div class="panel">
            <h3>üìç –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏</h3>
            <div class="input-group">
                <label for="xInput">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ X (128-255):</label>
                <input type="number" id="xInput" value="200" min="128" max="255">
            </div>
            
            <div class="input-group">
                <label for="yInput">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ Y (0-127):</label>
                <input type="number" id="yInput" value="64" min="0" max="127">
            </div>
        </div>

        <div style="text-align: center; margin: 20px 0;">
            <button onclick="initializeBox()" style="background: #27ae60;">üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–æ–∫—Å</button>
            <button onclick="encryptCoordinates()" style="background: #e67e22;">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="decryptCoordinates()" style="background: #3498db;">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="runTests()" style="background: #9b59b6;">üß™ –¢–µ—Å—Ç –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏</button>
            <button onclick="clearAll()" style="background: #e74c3c;">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
        </div>
        
        <div id="status" class="status waiting">–°—Ç–∞—Ç—É—Å: –ë–æ–∫—Å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω</div>
        
        <div id="result" class="result">
            <div class="coordinates">
                <div class="coord-item"><strong>–ò—Å—Ö–æ–¥–Ω—ã–µ:</strong> <span id="originalCoords">-</span></div>
                <div class="coord-item"><strong>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ:</strong> <span id="encryptedCoords">-</span></div>
                <div class="coord-item"><strong>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ:</strong> <span id="decryptedCoords">-</span></div>
                <div class="coord-item"><strong>–°–æ—Å—Ç–æ—è–Ω–∏–µ:</strong> <span id="resultState">–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π</span></div>
            </div>
            
            <div id="testResults" class="test-results" style="display: none;">
                <h4>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:</h4>
                <div id="testResultsContent"></div>
            </div>
        </div>
    </div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let encryptLut = null;
        let decryptLut = null;
        let isBoxInitialized = false;

        // –§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –±–æ–∫—Å–∞
        async function initializeBox() {
            const passphrase = document.getElementById('passphrase').value;
            const saltHex = document.getElementById('salt').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            
            updateStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...', 'waiting');
            
            if (!passphrase) {
                updateStatus('–û—à–∏–±–∫–∞: –í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É', 'error');
                return;
            }

            try {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Å–æ–ª—å –∏–∑ HEX
                const salt = hexToBytes(saltHex);
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á –∏–∑ –ø–∞—Ä–æ–ª—è
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    new TextEncoder().encode(passphrase),
                    'PBKDF2',
                    false,
                    ['deriveBits']
                );
                
                // Derive key using PBKDF2
                const derivedKey = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: iterations,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    256
                );

                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–æ–∫—Å
                await createScrambleBox(new Uint8Array(derivedKey));
                isBoxInitialized = true;
                updateStatus('–ë–æ–∫—Å —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω', 'ready');
                
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message, 'error');
            }
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–∫—Ä–µ–º–±–ª–∏—Ä—É—é—â–µ–≥–æ –±–æ–∫—Å–∞
        async function createScrambleBox(key) {
            // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
            const xCoords = Array.from({length: 128}, (_, i) => i + 128);
            const yCoords = Array.from({length: 128}, (_, i) => i);
            
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å –ø–æ–º–æ—â—å—é HMAC-based Fisher-Yates
            const shuffledX = await fisherYatesShuffle(xCoords, key, 'x');
            const shuffledY = await fisherYatesShuffle(yCoords, key, 'y');
            
            // –°–æ–∑–¥–∞–µ–º LUT —Ç–∞–±–ª–∏—Ü—ã
            encryptLut = new Array(256);
            decryptLut = new Array(256);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤—ã
            for (let i = 0; i < 256; i++) {
                encryptLut[i] = new Array(128);
                decryptLut[i] = new Array(128);
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—ã
            for (let i = 0; i < 128; i++) {
                for (let j = 0; j < 128; j++) {
                    const origX = xCoords[i];
                    const origY = yCoords[j];
                    const encX = shuffledX[i];
                    const encY = shuffledY[j];
                    
                    // –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    encryptLut[origX][origY] = [encX, encY];
                    
                    // –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    decryptLut[encX][encY] = [origX, origY];
                }
            }
        }

        // HMAC-based Fisher-Yates shuffle (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        async function fisherYatesShuffle(array, key, domain) {
            const shuffled = [...array];
            const hmacKey = await crypto.subtle.importKey(
                'raw',
                key,
                { name: 'HMAC', hash: 'SHA-256' },
                false,
                ['sign']
            );
            
            for (let i = shuffled.length - 1; i > 0; i--) {
                // –ì–µ–Ω–µ—Ä–∏–º HMAC –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞
                const data = new TextEncoder().encode(domain + i.toString());
                const hmac = await crypto.subtle.sign('HMAC', hmacKey, data);
                
                // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [0, i]
                const randomValue = await getUniformRandomValue(hmac, i + 1);
                
                // –ú–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
                [shuffled[i], shuffled[randomValue]] = [shuffled[randomValue], shuffled[i]];
            }
            
            return shuffled;
        }

        // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞
        async function getUniformRandomValue(hmacBuffer, max) {
            const view = new DataView(hmacBuffer);
            let randomValue;
            let counter = 0;
            const maxValid = Math.floor(0x100000000 / max) * max;
            
            do {
                if (counter * 4 >= hmacBuffer.byteLength) {
                    // –ï—Å–ª–∏ HMAC –∑–∞–∫–æ–Ω—á–∏–ª—Å—è, –≥–µ–Ω–µ—Ä–∏–º –Ω–æ–≤—ã–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ
                    const newData = new Uint8Array(hmacBuffer);
                    hmacBuffer = await crypto.subtle.sign('HMAC', 
                        await crypto.subtle.importKey('raw', newData, 
                        { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']), 
                        new TextEncoder().encode('refresh'));
                    view = new DataView(hmacBuffer);
                    counter = 0;
                }
                
                randomValue = view.getUint32(counter * 4) >>> 0;
                counter++;
                
            } while (randomValue >= maxValid);
            
            return randomValue % max;
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        function encryptCoordinates() {
            if (!validateBox() || !validateInputCoordinates()) return;
            
            const x = parseInt(document.getElementById('xInput').value);
            const y = parseInt(document.getElementById('yInput').value);
            
            const encrypted = encryptLut[x][y];
            
            document.getElementById('originalCoords').textContent = 
                `X=${x}, Y=${y} (HEX: ${toHex(x)} ${toHex(y)})`;
            document.getElementById('encryptedCoords').textContent = 
                `X=${encrypted[0]}, Y=${encrypted[1]} (HEX: ${toHex(encrypted[0])} ${toHex(encrypted[1])})`;
            document.getElementById('decryptedCoords').textContent = '-';
            document.getElementById('resultState').textContent = '–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ';
            
            document.getElementById('result').classList.remove('success');
            document.getElementById('result').classList.add('success');
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        function decryptCoordinates() {
            if (!validateBox() || !validateInputCoordinates()) return;
            
            const x = parseInt(document.getElementById('xInput').value);
            const y = parseInt(document.getElementById('yInput').value);
            
            const decrypted = decryptLut[x][y];
            
            document.getElementById('decryptedCoords').textContent = 
                `X=${decrypted[0]}, Y=${decrypted[1]} (HEX: ${toHex(decrypted[0])} ${toHex(decrypted[1])})`;
            document.getElementById('resultState').textContent = '–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ';
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏
            const shouldBeOriginal = encryptLut[decrypted[0]][decrypted[1]];
            if (shouldBeOriginal[0] === x && shouldBeOriginal[1] === y) {
                document.getElementById('resultState').textContent += ' ‚úÖ –û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞';
            }
        }

        // –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏
        async function runTests() {
            if (!validateBox()) return;
            
            updateStatus('–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏...', 'waiting');
            document.getElementById('testResults').style.display = 'block';
            const testResults = document.getElementById('testResultsContent');
            testResults.innerHTML = '';
            
            let passed = 0;
            let failed = 0;
            const testPoints = [
                [128, 0], [255, 127], [200, 64], [150, 32], [128, 127],
                [255, 0], [180, 90], [200, 100], [128, 64], [255, 64]
            ];
            
            for (const [x, y] of testPoints) {
                const testItem = document.createElement('div');
                testItem.className = 'test-item';
                
                try {
                    const encrypted = encryptLut[x][y];
                    const decrypted = decryptLut[encrypted[0]][encrypted[1]];
                    
                    if (decrypted[0] === x && decrypted[1] === y) {
                        testItem.innerHTML = `‚úÖ –¢–µ—Å—Ç (${x}, ${y}) -> (${encrypted[0]}, ${encrypted[1]}) -> (${decrypted[0]}, ${decrypted[1]})`;
                        testItem.className += ' test-pass';
                        passed++;
                    } else {
                        testItem.innerHTML = `‚ùå –¢–µ—Å—Ç (${x}, ${y}) - –ù–µ –æ–±—Ä–∞—Ç–∏–º–æ!`;
                        testItem.className += ' test-fail';
                        failed++;
                    }
                } catch (error) {
                    testItem.innerHTML = `‚ùå –¢–µ—Å—Ç (${x}, ${y}) - –û—à–∏–±–∫–∞: ${error.message}`;
                    testItem.className += ' test-fail';
                    failed++;
                }
                
                testResults.appendChild(testItem);
            }
            
            const summary = document.createElement('div');
            summary.className = 'test-item';
            summary.innerHTML = `<strong>–ò—Ç–æ–≥: ${passed} –ø—Ä–æ–π–¥–µ–Ω–æ, ${failed} –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–æ</strong>`;
            testResults.appendChild(summary);
            
            updateStatus(`–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: ${passed}/${passed + failed} –ø—Ä–æ–π–¥–µ–Ω–æ`, 
                        failed === 0 ? 'ready' : 'error');
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        function hexToBytes(hex) {
            if (hex.length % 2 !== 0) throw new Error("HEX —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —á–µ—Ç–Ω—É—é –¥–ª–∏–Ω—É");
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i/2] = parseInt(hex.substr(i, 2), 16);
            }
            return bytes;
        }

        function toHex(number) {
            return number.toString(16).padStart(2, '0').toUpperCase();
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function validateBox() {
            if (!isBoxInitialized) {
                updateStatus('–û—à–∏–±–∫–∞: –°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å', 'error');
                return false;
            }
            return true;
        }

        function validateInputCoordinates() {
            const x = parseInt(document.getElementById('xInput').value);
            const y = parseInt(document.getElementById('yInput').value);
            
            if (isNaN(x) || isNaN(y) || x < 128 || x > 255 || y < 0 || y > 127) {
                updateStatus('–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã', 'error');
                return false;
            }
            return true;
        }

        function clearAll() {
            encryptLut = null;
            decryptLut = null;
            isBoxInitialized = false;
            
            document.getElementById('originalCoords').textContent = '-';
            document.getElementById('encryptedCoords').textContent = '-';
            document.getElementById('decryptedCoords').textContent = '-';
            document.getElementById('resultState').textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π';
            document.getElementById('testResults').style.display = 'none';
            
            document.getElementById('result').classList.remove('success');
            updateStatus('–ë–æ–∫—Å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω', 'waiting');
        }

        // –ê–≤—Ç–æ-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', function() {
            setTimeout(initializeBox, 1000);
        });
    </script>
</body>
</html>
