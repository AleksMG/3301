<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä 2–±–∞–π—Ç‚Üí2–±–∞–π—Ç</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Courier New', monospace; 
            background: #1a1a1a; 
            color: #00ff00; 
            padding: 20px; 
            line-height: 1.6;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: #2a2a2a; 
            padding: 20px; 
            border: 2px solid #00ff00;
            border-radius: 10px;
        }
        h1, h2, h3 { 
            color: #00ff00; 
            margin-bottom: 20px; 
            text-align: center;
        }
        .panel {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #00ff00;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #00ff00;
        }
        input, textarea, button {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ff00;
            background: #000;
            color: #00ff00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
        }
        .result-area {
            margin-top: 20px;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            border: 2px solid #00ff00;
        }
        .hex-view {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #444;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }
        .success { background: #004400; color: #00ff00; }
        .error { background: #440000; color: #ff0000; }
        .warning { background: #443300; color: #ffcc00; }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .vis-box {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        .coord-pair {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: #222;
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê –û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä 2–±–∞–π—Ç‚Üí2–±–∞–π—Ç</h1>
        
        <div class="panel">
            <h2>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–ª—é—á–∞</h2>
            <div class="input-group">
                <label for="passphrase">–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞:</label>
                <input type="text" id="passphrase" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π-–∫–ª—é—á-123" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É">
            </div>
            <div class="input-group">
                <label for="salt">–°–æ–ª—å (HEX):</label>
                <input type="text" id="salt" value="a1b2c3d4e5f67890" placeholder="a1b2c3d4...">
            </div>
            <button onclick="initializeBox()">üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–æ–∫—Å</button>
        </div>

        <div class="panel">
            <h2>üìù –í–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞</h2>
            <div class="input-group">
                <label for="inputText">–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
                <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...">Hello World!</textarea>
            </div>
            <div class="input-group">
                <label for="encryptedText">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (HEX):</label>
                <textarea id="encryptedText" placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ HEX..."></textarea>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="encryptText()" style="background: #ff9900;">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                <button onclick="decryptText()" style="background: #0099ff;">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>

        <div id="status" class="status warning">–°—Ç–∞—Ç—É—Å: –ë–æ–∫—Å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω</div>

        <div class="result-area">
            <h2>üëÅÔ∏è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π</h2>
            <div class="visualization">
                <div class="vis-box">
                    <h3>üìä –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h3>
                    <div id="encryptionVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
                <div class="vis-box">
                    <h3>üìä –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h3>
                    <div id="decryptionVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
            </div>
            
            <h3>üî¢ HEX –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ</h3>
            <div class="hex-view" id="hexView">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            
            <h3>üìã –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π</h3>
            <div class="hex-view" id="history">–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π...</div>
        </div>
    </div>

    <script>
        class OmoCipher {
            constructor() {
                this.box = null;
                this.reverseMap = null;
                this.isInitialized = false;
            }

            async initialize(passphrase, saltHex) {
                const salt = this.hexToBytes(saltHex);
                const keyMaterial = await crypto.subtle.importKey(
                    'raw', new TextEncoder().encode(passphrase), 'PBKDF2', false, ['deriveBits']
                );
                
                const derivedKey = await crypto.subtle.deriveBits(
                    { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                    keyMaterial, 256
                );

                await this.createBox(new Uint8Array(derivedKey));
                this.isInitialized = true;
            }

            async createBox(key) {
                // –°–æ–∑–¥–∞–µ–º 128x128 —è—á–µ–µ–∫
                this.box = new Array(256);
                this.reverseMap = new Map();
                
                for (let x = 128; x < 256; x++) {
                    this.box[x] = new Array(128);
                    for (let y = 0; y < 128; y++) {
                        // 4 –æ–º–æ—Ñ–æ–Ω–∞ –≤ –∫–∞–∂–¥–æ–π —è—á–µ–π–∫–µ
                        this.box[x][y] = [
                            this.generateOmo—Ñ–æ–Ω(x, y, 0, key),
                            this.generateOmo—Ñ–æ–Ω(x, y, 1, key),
                            this.generateOmo—Ñ–æ–Ω(x, y, 2, key),
                            this.generateOmo—Ñ–æ–Ω(x, y, 3, key)
                        ];
                        
                        // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é –∫–∞—Ä—Ç—É
                        this.box[x][y].forEach(omo—Ñ–æ–Ω => {
                            this.reverseMap.set(omo—Ñ–æ–Ω, { x, y });
                        });
                    }
                }
            }

            generateOmo—Ñ–æ–Ω(x, y, index, key) {
                // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–º–æ—Ñ–æ–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∏ –∫–ª—é—á–∞
                const data = new TextEncoder().encode(`${x}-${y}-${index}`);
                let hash = 0;
                
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data[i];
                    hash |= 0;
                }
                
                for (let i = 0; i < key.length; i++) {
                    hash = ((hash << 3) - hash) + key[i];
                    hash |= 0;
                }
                
                return Math.abs(hash) % 65536;
            }

            encrypt(x, y) {
                if (!this.isValidCoord(x, y)) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã');
                const omophones = this.box[x][y];
                const randomIndex = Math.floor(Math.random() * 4);
                return {
                    value: omophones[randomIndex],
                    index: randomIndex,
                    x, y
                };
            }

            decrypt(omo—Ñ–æ–Ω) {
                const coords = this.reverseMap.get(omo—Ñ–æ–Ω);
                if (!coords) throw new Error('–û–º–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return coords;
            }

            isValidCoord(x, y) {
                return x >= 128 && x <= 255 && y >= 0 && y <= 127;
            }

            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i/2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes;
            }

            bytesToHex(bytes) {
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            }

            textToCoords(text) {
                const bytes = new TextEncoder().encode(text);
                const coords = [];
                
                for (let i = 0; i < bytes.length; i += 2) {
                    const x = bytes[i];
                    const y = i + 1 < bytes.length ? bytes[i + 1] : 0;
                    coords.push({ x, y });
                }
                
                return coords;
            }

            coordsToText(coords) {
                const bytes = new Uint8Array(coords.length * 2);
                
                coords.forEach((coord, index) => {
                    bytes[index * 2] = coord.x;
                    bytes[index * 2 + 1] = coord.y;
                });
                
                return new TextDecoder().decode(bytes);
            }
        }

        const cipher = new OmoCipher();
        let operationHistory = [];

        async function initializeBox() {
            const passphrase = document.getElementById('passphrase').value;
            const salt = document.getElementById('salt').value;
            
            try {
                updateStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ–∫—Å–∞...', 'warning');
                await cipher.initialize(passphrase, salt);
                updateStatus('–ë–æ–∫—Å —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!', 'success');
                addToHistory('–°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Å –Ω–æ–≤—ã–º –∫–ª—é—á–æ–º');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message, 'error');
            }
        }

        function encryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å!', 'error');
                return;
            }

            const text = document.getElementById('inputText').value;
            if (!text) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const coords = cipher.textToCoords(text);
                const encrypted = [];
                let hexOutput = '';
                let visHtml = '';

                coords.forEach(coord => {
                    const result = cipher.encrypt(coord.x, coord.y);
                    encrypted.push(result.value);
                    
                    hexOutput += result.value.toString(16).padStart(4, '0') + ' ';
                    visHtml += `
                        <div class="coord-pair">
                            <span>(${coord.x},${coord.y})</span>
                            <span>‚Üí</span>
                            <span>0x${result.value.toString(16).padStart(4, '0')}</span>
                        </div>
                    `;
                });

                document.getElementById('encryptedText').value = hexOutput.trim();
                document.getElementById('encryptionVis').innerHTML = visHtml;
                document.getElementById('hexView').textContent = `HEX: ${hexOutput}`;
                
                addToHistory(`–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: "${text}" -> ${hexOutput}`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function decryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å!', 'error');
                return;
            }

            const hexText = document.getElementById('encryptedText').value;
            if (!hexText) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ HEX –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const hexValues = hexText.trim().split(/\s+/);
                const coords = [];
                let visHtml = '';
                let decryptedText = '';

                hexValues.forEach(hex => {
                    const value = parseInt(hex, 16);
                    if (isNaN(value)) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π HEX —Ñ–æ—Ä–º–∞—Ç');
                    
                    const coord = cipher.decrypt(value);
                    coords.push(coord);
                    
                    visHtml += `
                        <div class="coord-pair">
                            <span>0x${hex.padStart(4, '0')}</span>
                            <span>‚Üí</span>
                            <span>(${coord.x},${coord.y})</span>
                        </div>
                    `;
                });

                decryptedText = cipher.coordsToText(coords);
                document.getElementById('inputText').value = decryptedText;
                document.getElementById('decryptionVis').innerHTML = visHtml;
                
                addToHistory(`–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${hexText} -> "${decryptedText}"`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function addToHistory(message) {
            operationHistory.push(`${new Date().toLocaleTimeString()}: ${message}`);
            if (operationHistory.length > 10) operationHistory.shift();
            document.getElementById('history').textContent = operationHistory.join('\n');
        }

        // –ê–≤—Ç–æ-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => {
            setTimeout(initializeBox, 1000);
        });
    </script>
</body>
</html>
