<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä 16x16x16</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Courier New', monospace; 
            background: #1a1a1a; 
            color: #00ff00; 
            padding: 20px; 
            line-height: 1.6;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: #2a2a2a; 
            padding: 20px; 
            border: 2px solid #00ff00;
            border-radius: 10px;
        }
        h1, h2, h3 { 
            color: #00ff00; 
            margin-bottom: 20px; 
            text-align: center;
        }
        .panel {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #00ff00;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #00ff00;
        }
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ff00;
            background: #000;
            color: #00ff00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
        }
        .result-area {
            margin-top: 20px;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            border: 2px solid #00ff00;
        }
        .hex-view {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #444;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }
        .success { background: #004400; color: #00ff00; }
        .error { background: #440000; color: #ff0000; }
        .warning { background: #443300; color: #ffcc00; }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .vis-box {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        .byte-pair {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: #222;
            border-radius: 3px;
            font-size: 12px;
        }
        .process-step {
            margin: 10px 0;
            padding: 10px;
            background: #222;
            border-radius: 5px;
            border-left: 3px solid #00ff00;
        }
        
        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê –û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä 16x16x16</h1>
        
        <div class="panel">
            <h2>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–ª—é—á–∞</h2>
            <div class="input-group">
                <label for="passphrase">–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞:</label>
                <input type="text" id="passphrase" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π-–∫–ª—é—á-123" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É">
            </div>
            <div class="input-group">
                <label for="salt">–°–æ–ª—å (HEX):</label>
                <input type="text" id="salt" value="a1b2c3d4e5f67890" placeholder="a1b2c3d4...">
            </div>
            <button onclick="initializeBox()">üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–æ–∫—Å—ã</button>
        </div>

        <div class="panel">
            <h2>üìù –í–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞</h2>
            <div class="input-group">
                <label for="inputText">–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
                <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...">Hello World! –ü—Ä–∏–≤–µ—Ç –º–∏—Ä!</textarea>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="encryptText()" style="background: #ff9900;">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                <button onclick="decryptText()" style="background: #0099ff;">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>

        <div id="status" class="status warning">–°—Ç–∞—Ç—É—Å: –ë–æ–∫—Å—ã –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã</div>

        <div class="result-area">
            <h2>üëÅÔ∏è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞</h2>
            
            <div class="process-step" id="preparationStep">
                <h3>üìã –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –±–∞–π—Ç–æ–≤</h3>
                <div id="preparationVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>

            <div class="visualization">
                <div class="vis-box">
                    <h3>üî¢ –í—ã–±–æ—Ä S-Box</h3>
                    <div id="sboxSelectionVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
                <div class="vis-box">
                    <h3>üî¢ –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ S-Box</h3>
                    <div id="coordinatesVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
            </div>

            <div class="process-step" id="encryptionStep">
                <h3>üîê –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h3>
                <div id="encryptionVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>

            <div class="process-step" id="resultStep">
                <h3>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
                <div class="input-group">
                    <label for="encryptedText">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (HEX):</label>
                    <textarea id="encryptedText" placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ HEX..."></textarea>
                </div>
                <div class="hex-view" id="hexView">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>
            
            <h3>üìã –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π</h3>
            <div class="hex-view" id="history">–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π...</div>
        </div>
    </div>

    <script>
        class OmoCipher {
            constructor() {
                this.sBoxes = new Array(16); // 16 S-Box'–æ–≤
                this.reverseMap = new Map(); // –æ–º–æ—Ñ–æ–Ω ‚Üí {sboxIndex, x, y}
                this.isInitialized = false;
            }

            async initialize(passphrase, saltHex) {
                const salt = this.hexToBytes(saltHex);
                const keyMaterial = await crypto.subtle.importKey(
                    'raw', new TextEncoder().encode(passphrase), 'PBKDF2', false, ['deriveBits']
                );
                
                const derivedKey = await crypto.subtle.deriveBits(
                    { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                    keyMaterial, 256
                );

                await this.createSBoxes(new Uint8Array(derivedKey));
                this.isInitialized = true;
            }

            async createSBoxes(key) {
                // –°–æ–∑–¥–∞–µ–º 16 S-Box'–æ–≤ —Ä–∞–∑–º–µ—Ä–æ–º 16x256
                for (let sboxIndex = 0; sboxIndex < 16; sboxIndex++) {
                    this.sBoxes[sboxIndex] = new Array(16);
                    
                    for (let x = 0; x < 16; x++) {
                        this.sBoxes[sboxIndex][x] = new Array(256);
                        
                        for (let y = 0; y < 256; y++) {
                            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 4 –æ–º–æ—Ñ–æ–Ω–∞ –¥–ª—è –∫–∞–∂–¥–æ–π —è—á–µ–π–∫–∏
                            const omophones = [
                                this.generateOmophone(sboxIndex, x, y, 0, key),
                                this.generateOmophone(sboxIndex, x, y, 1, key),
                                this.generateOmophone(sboxIndex, x, y, 2, key),
                                this.generateOmophone(sboxIndex, x, y, 3, key)
                            ];
                            
                            this.sBoxes[sboxIndex][x][y] = omophones;
                            
                            // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é –∫–∞—Ä—Ç—É
                            omophones.forEach(omophone => {
                                this.reverseMap.set(omophone, { sboxIndex, x, y });
                            });
                        }
                    }
                }
            }

            generateOmophone(sboxIndex, x, y, index, key) {
                const data = new TextEncoder().encode(`${sboxIndex}-${x}-${y}-${index}-${key}`);
                let hash = 0;
                
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data[i];
                    hash |= 0;
                }
                
                return Math.abs(hash) % 65536;
            }

            encryptPair(byte1, byte2) {
                // –†–∞–∑–±–∏—Ä–∞–µ–º –ø–µ—Ä–≤—ã–π –±–∞–π—Ç –Ω–∞ –Ω–∏–±–ª—ã
                const highNibble = (byte1 >> 4) & 0x0F; // –°—Ç–∞—Ä—à–∏–π –Ω–∏–±–ª (0-15)
                const lowNibble = byte1 & 0x0F;         // –ú–ª–∞–¥—à–∏–π –Ω–∏–±–ª (0-15)
                
                // –í—ã–±–∏—Ä–∞–µ–º S-Box based on high nibble
                const sboxIndex = highNibble;
                const x = lowNibble;
                const y = byte2;
                
                // –®–∏—Ñ—Ä—É–µ–º
                const omophones = this.sBoxes[sboxIndex][x][y];
                const randomIndex = Math.floor(Math.random() * omophones.length);
                const omophone = omophones[randomIndex];
                
                return {
                    omophone,
                    sboxIndex,
                    x,
                    y,
                    highNibble,
                    lowNibble,
                    index: randomIndex
                };
            }

            decryptPair(omophone) {
                const { sboxIndex, x, y } = this.reverseMap.get(omophone);
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–≤—ã–π –±–∞–π—Ç
                const byte1 = (sboxIndex << 4) | x;
                // –í—Ç–æ—Ä–æ–π –±–∞–π—Ç –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
                const byte2 = y;
                
                return { byte1, byte2, sboxIndex, x, y };
            }

            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i/2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes;
            }
        }

        const cipher = new OmoCipher();
        let operationHistory = [];

        async function initializeBox() {
            const passphrase = document.getElementById('passphrase').value;
            const salt = document.getElementById('salt').value;
            
            try {
                updateStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è 16 S-Box\'–æ–≤...', 'warning');
                await cipher.initialize(passphrase, salt);
                updateStatus('16 S-Box\'–æ–≤ —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã!', 'success');
                addToHistory('–°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Å –Ω–æ–≤—ã–º –∫–ª—é—á–æ–º (16 S-Box\'–æ–≤)');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message, 'error');
            }
        }

        function encryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å—ã!', 'error');
                return;
            }

            const text = document.getElementById('inputText').value;
            
            if (!text) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const bytes = new TextEncoder().encode(text);
                let encryptedHex = '';
                let prepHtml = '';
                let sboxHtml = '';
                let coordHtml = '';
                let encHtml = '';

                for (let i = 0; i < bytes.length; i += 2) {
                    const byte1 = bytes[i];
                    const byte2 = bytes[i + 1] || 0;
                    
                    const result = cipher.encryptPair(byte1, byte2);
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏
                    prepHtml += `<div>–ë–∞–π—Ç—ã ${i}-${i+1}: [0x${byte1.toString(16).padStart(2, '0')}, 0x${byte2.toString(16).padStart(2, '0')}]</div>`;
                    prepHtml += `<div>‚Üí –ù–∏–±–ª—ã: [0x${result.highNibble.toString(16)}][0x${result.lowNibble.toString(16)}]</div>`;
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≤—ã–±–æ—Ä–∞ S-Box
                    sboxHtml += `<div class="byte-pair">S-Box[${result.sboxIndex}] –¥–ª—è –Ω–∏–±–ª–∞ 0x${result.highNibble.toString(16)}</div>`;
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                    coordHtml += `<div class="byte-pair">–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: X=0x${result.x.toString(16)}, Y=0x${result.y.toString(16).padStart(2, '0')}</div>`;
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    encHtml += `<div class="byte-pair">[0x${byte1.toString(16).padStart(2, '0')}, 0x${byte2.toString(16).padStart(2, '0')}] ‚Üí 0x${result.omophone.toString(16).padStart(4, '0')}</div>`;
                    
                    encryptedHex += result.omophone.toString(16).padStart(4, '0') + ' ';
                }

                document.getElementById('preparationVis').innerHTML = prepHtml;
                document.getElementById('sboxSelectionVis').innerHTML = sboxHtml;
                document.getElementById('coordinatesVis').innerHTML = coordHtml;
                document.getElementById('encryptionVis').innerHTML = encHtml;
                
                document.getElementById('encryptedText').value = encryptedHex.trim();
                document.getElementById('hexView').textContent = `HEX: ${encryptedHex.trim()}`;
                
                addToHistory(`–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: "${text}" -> ${encryptedHex.trim()}`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');

            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function decryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å—ã!', 'error');
                return;
            }

            const hexText = document.getElementById('encryptedText').value;
            
            if (!hexText) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ HEX –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const hexValues = hexText.trim().split(/\s+/);
                let decryptedBytes = [];
                let decHtml = '';

                for (const hex of hexValues) {
                    const omophone = parseInt(hex, 16);
                    if (isNaN(omophone)) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π HEX —Ñ–æ—Ä–º–∞—Ç');
                    
                    const result = cipher.decryptPair(omophone);
                    decryptedBytes.push(result.byte1);
                    if (result.byte2 !== 0) decryptedBytes.push(result.byte2);
                    
                    decHtml += `<div class="byte-pair">0x${hex.padStart(4, '0')} ‚Üí [0x${result.byte1.toString(16).padStart(2, '0')}, 0x${result.byte2.toString(16).padStart(2, '0')}]</div>`;
                }

                const decryptedText = new TextDecoder().decode(new Uint8Array(decryptedBytes));
                document.getElementById('inputText').value = decryptedText;
                document.getElementById('encryptionVis').innerHTML = decHtml;
                
                addToHistory(`–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${hexText} -> "${decryptedText}"`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');

            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function addToHistory(message) {
            operationHistory.push(`${new Date().toLocaleTimeString()}: ${message}`);
            if (operationHistory.length > 10) operationHistory.shift();
            document.getElementById('history').textContent = operationHistory.join('\n');
        }

        window.addEventListener('load', () => {
            setTimeout(initializeBox, 1000);
        });
    </script>
</body>
</html>
