<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä 2.0</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Courier New', monospace; 
            background: #1a1a1a; 
            color: #00ff00; 
            padding: 20px; 
            line-height: 1.6;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: #2a2a2a; 
            padding: 20px; 
            border: 2px solid #00ff00;
            border-radius: 10px;
        }
        h1, h2, h3 { 
            color: #00ff00; 
            margin-bottom: 20px; 
            text-align: center;
        }
        .panel {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #00ff00;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #00ff00;
        }
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ff00;
            background: #000;
            color: #00ff00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
        }
        .result-area {
            margin-top: 20px;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            border: 2px solid #00ff00;
        }
        .hex-view {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #444;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }
        .success { background: #004400; color: #00ff00; }
        .error { background: #440000; color: #ff0000; }
        .warning { background: #443300; color: #ffcc00; }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .vis-box {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        .byte-pair {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: #222;
            border-radius: 3px;
            font-size: 12px;
        }
        .process-step {
            margin: 10px 0;
            padding: 10px;
            background: #222;
            border-radius: 5px;
            border-left: 3px solid #00ff00;
        }
        
        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê –û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä 2.0 (128x128)</h1>
        
        <div class="panel">
            <h2>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–ª—é—á–∞</h2>
            <div class="input-group">
                <label for="passphrase">–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞:</label>
                <input type="text" id="passphrase" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π-–∫–ª—é—á-123" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É">
            </div>
            <div class="input-group">
                <label for="salt">–°–æ–ª—å (HEX):</label>
                <input type="text" id="salt" value="a1b2c3d4e5f67890" placeholder="a1b2c3d4...">
            </div>
            <button onclick="initializeBox()">üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–æ–∫—Å</button>
        </div>

        <div class="panel">
            <h2>üìù –í–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞</h2>
            <div class="input-group">
                <label for="inputText">–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
                <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...">Hello World! –ü—Ä–∏–≤–µ—Ç –º–∏—Ä!</textarea>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="encryptText()" style="background: #ff9900;">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                <button onclick="decryptText()" style="background: #0099ff;">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>

        <div id="status" class="status warning">–°—Ç–∞—Ç—É—Å: –ë–æ–∫—Å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω</div>

        <div class="result-area">
            <h2>üëÅÔ∏è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞</h2>
            
            <div class="process-step" id="preparationStep">
                <h3>üìã –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –±–∞–π—Ç–æ–≤</h3>
                <div id="preparationVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>

            <div class="visualization">
                <div class="vis-box">
                    <h3>üî¢ X-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (128-255)</h3>
                    <div id="xCoordsVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
                <div class="vis-box">
                    <h3>üî¢ Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (0-127)</h3>
                    <div id="yCoordsVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
            </div>

            <div class="process-step" id="encryptionStep">
                <h3>üîê –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h3>
                <div id="encryptionVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>

            <div class="process-step" id="resultStep">
                <h3>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
                <div class="input-group">
                    <label for="encryptedText">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (HEX):</label>
                    <textarea id="encryptedText" placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ HEX..."></textarea>
                </div>
                <div class="hex-view" id="hexView">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>
            
            <h3>üìã –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π</h3>
            <div class="hex-view" id="history">–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π...</div>
        </div>
    </div>

    <script>
        class OmoCipher {
            constructor() {
                this.sBox = null;        // 128x128 S-Box
                this.reverseMap = null;  // –æ–º–æ—Ñ–æ–Ω -> (x,y)
                this.isInitialized = false;
            }

            async initialize(passphrase, saltHex) {
                const salt = this.hexToBytes(saltHex);
                const keyMaterial = await crypto.subtle.importKey(
                    'raw', new TextEncoder().encode(passphrase), 'PBKDF2', false, ['deriveBits']
                );
                
                const derivedKey = await crypto.subtle.deriveBits(
                    { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                    keyMaterial, 256
                );

                await this.createSBox(new Uint8Array(derivedKey));
                this.isInitialized = true;
            }

            async createSBox(key) {
                // –°–æ–∑–¥–∞–µ–º S-Box 128x128
                this.sBox = new Array(128);
                this.reverseMap = new Map();
                
                // X: 128-255, Y: 0-127
                for (let x = 128; x < 256; x++) {
                    this.sBox[x - 128] = new Array(128);
                    for (let y = 0; y < 128; y++) {
                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 4 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –æ–º–æ—Ñ–æ–Ω–∞
                        const omophones = [
                            this.generateOmophone(x, y, 0, key),
                            this.generateOmophone(x, y, 1, key),
                            this.generateOmophone(x, y, 2, key),
                            this.generateOmophone(x, y, 3, key)
                        ];
                        
                        this.sBox[x - 128][y] = omophones;
                        
                        // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é –∫–∞—Ä—Ç—É
                        omophones.forEach(omophone => {
                            this.reverseMap.set(omophone, { x, y });
                        });
                    }
                }
            }

            generateOmophone(x, y, index, key) {
                const data = new TextEncoder().encode(`${x}-${y}-${index}-${key}`);
                let hash = 0;
                
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data[i];
                    hash |= 0;
                }
                
                return Math.abs(hash) % 65536;
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–∞ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É
            byteToCoord(byte) {
                if (byte >= 128) {
                    return { coord: byte, original: byte, type: 'upper' };
                } else {
                    return { coord: byte + 128, original: byte, type: 'lower' };
                }
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –±–∞–π—Ç
            coordToByte(coord, originalType) {
                if (originalType === 'upper') {
                    return coord;
                } else {
                    return coord - 128;
                }
            }

            encryptPair(byte1, byte2) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç—ã –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                const coord1 = this.byteToCoord(byte1);
                const coord2 = this.byteToCoord(byte2);
                
                // –®–∏—Ñ—Ä—É–µ–º
                const omophones = this.sBox[coord1.coord - 128][coord2.coord];
                const randomIndex = Math.floor(Math.random() * omophones.length);
                const omophone = omophones[randomIndex];
                
                return {
                    omophone,
                    coord1,
                    coord2,
                    index: randomIndex
                };
            }

            decryptPair(omophone) {
                const { x, y } = this.reverseMap.get(omophone);
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –±–∞–π—Ç—ã
                const byte1 = x >= 128 ? x : x + 128;
                const byte2 = y < 128 ? y : y - 128;
                
                return { byte1, byte2, x, y };
            }

            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i/2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes;
            }
        }

        const cipher = new OmoCipher();
        let operationHistory = [];

        async function initializeBox() {
            const passphrase = document.getElementById('passphrase').value;
            const salt = document.getElementById('salt').value;
            
            try {
                updateStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ–∫—Å–∞...', 'warning');
                await cipher.initialize(passphrase, salt);
                updateStatus('–ë–æ–∫—Å —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!', 'success');
                addToHistory('–°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Å –Ω–æ–≤—ã–º –∫–ª—é—á–æ–º');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message, 'error');
            }
        }

        function encryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å!', 'error');
                return;
            }

            const text = document.getElementById('inputText').value;
            
            if (!text) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const bytes = new TextEncoder().encode(text);
                let encryptedHex = '';
                let prepHtml = '';
                let xHtml = '';
                let yHtml = '';
                let encHtml = '';

                // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ 2 –±–∞–π—Ç–∞
                for (let i = 0; i < bytes.length; i += 2) {
                    const byte1 = bytes[i];
                    const byte2 = bytes[i + 1] || 0; // –ï—Å–ª–∏ –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –¥–æ–ø–æ–ª–Ω—è–µ–º 0
                    
                    const result = cipher.encryptPair(byte1, byte2);
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏
                    prepHtml += `<div>–ë–∞–π—Ç—ã ${i}-${i+1}: [${byte1}, ${byte2}] ‚Üí X=${result.coord1.coord}, Y=${result.coord2.coord}</div>`;
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                    xHtml += `<div class="byte-pair">X${Math.floor(i/2)}: ${result.coord1.coord} (0x${result.coord1.coord.toString(16).padStart(2, '0')})</div>`;
                    yHtml += `<div class="byte-pair">Y${Math.floor(i/2)}: ${result.coord2.coord} (0x${result.coord2.coord.toString(16).padStart(2, '0')})</div>`;
                    
                    // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
                    encHtml += `<div class="byte-pair">(${result.coord1.coord},${result.coord2.coord}) ‚Üí 0x${result.omophone.toString(16).padStart(4, '0')}</div>`;
                    
                    encryptedHex += result.omophone.toString(16).padStart(4, '0') + ' ';
                }

                document.getElementById('preparationVis').innerHTML = prepHtml;
                document.getElementById('xCoordsVis').innerHTML = xHtml;
                document.getElementById('yCoordsVis').innerHTML = yHtml;
                document.getElementById('encryptionVis').innerHTML = encHtml;
                
                document.getElementById('encryptedText').value = encryptedHex.trim();
                document.getElementById('hexView').textContent = `HEX: ${encryptedHex.trim()}`;
                
                addToHistory(`–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: "${text}" -> ${encryptedHex.trim()}`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');

            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function decryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å!', 'error');
                return;
            }

            const hexText = document.getElementById('encryptedText').value;
            
            if (!hexText) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ HEX –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const hexValues = hexText.trim().split(/\s+/);
                let decryptedBytes = [];
                let decHtml = '';

                for (const hex of hexValues) {
                    const omophone = parseInt(hex, 16);
                    if (isNaN(omophone)) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π HEX —Ñ–æ—Ä–º–∞—Ç');
                    
                    const result = cipher.decryptPair(omophone);
                    decryptedBytes.push(result.byte1);
                    if (result.byte2 !== 0) decryptedBytes.push(result.byte2);
                    
                    decHtml += `<div class="byte-pair">0x${hex.padStart(4, '0')} ‚Üí [${result.byte1}, ${result.byte2}]</div>`;
                }

                const decryptedText = new TextDecoder().decode(new Uint8Array(decryptedBytes));
                document.getElementById('inputText').value = decryptedText;
                document.getElementById('encryptionVis').innerHTML = decHtml;
                
                addToHistory(`–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${hexText} -> "${decryptedText}"`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');

            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function addToHistory(message) {
            operationHistory.push(`${new Date().toLocaleTimeString()}: ${message}`);
            if (operationHistory.length > 10) operationHistory.shift();
            document.getElementById('history').textContent = operationHistory.join('\n');
        }

        // –ê–≤—Ç–æ-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => {
            setTimeout(initializeBox, 1000);
        });
    </script>
</body>
</html>
