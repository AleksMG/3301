<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –±–∞–π—Ç–æ–≤</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Courier New', monospace; 
            background: #1a1a1a; 
            color: #00ff00; 
            padding: 20px; 
            line-height: 1.6;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: #2a2a2a; 
            padding: 20px; 
            border: 2px solid #00ff00;
            border-radius: 10px;
        }
        h1, h2, h3 { 
            color: #00ff00; 
            margin-bottom: 20px; 
            text-align: center;
        }
        .panel {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #00ff00;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #00ff00;
        }
        input, textarea, button, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #00ff00;
            background: #000;
            color: #00ff00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
        }
        .result-area {
            margin-top: 20px;
            padding: 20px;
            background: #333;
            border-radius: 8px;
            border: 2px solid #00ff00;
        }
        .hex-view {
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #444;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }
        .success { background: #004400; color: #00ff00; }
        .error { background: #440000; color: #ff0000; }
        .warning { background: #443300; color: #ffcc00; }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .vis-box {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        .byte-pair {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: #222;
            border-radius: 3px;
            font-size: 12px;
        }
        .process-step {
            margin: 10px 0;
            padding: 10px;
            background: #222;
            border-radius: 5px;
            border-left: 3px solid #00ff00;
        }
        
        @media (max-width: 768px) {
            .visualization {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê –û–º–æ—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π —à–∏—Ñ—Ä–∞—Ç–æ—Ä —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –±–∞–π—Ç–æ–≤</h1>
        
        <div class="panel">
            <h2>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–ª—é—á–∞</h2>
            <div class="input-group">
                <label for="passphrase">–ö–ª—é—á–µ–≤–∞—è —Ñ—Ä–∞–∑–∞:</label>
                <input type="text" id="passphrase" value="—Å–µ–∫—Ä–µ—Ç–Ω—ã–π-–∫–ª—é—á-123" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á–µ–≤—É—é —Ñ—Ä–∞–∑—É">
            </div>
            <div class="input-group">
                <label for="salt">–°–æ–ª—å (HEX):</label>
                <input type="text" id="salt" value="a1b2c3d4e5f67890" placeholder="a1b2c3d4...">
            </div>
            <button onclick="initializeBox()">üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–æ–∫—Å</button>
        </div>

        <div class="panel">
            <h2>üìù –í–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞</h2>
            <div class="input-group">
                <label for="inputText">–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:</label>
                <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è...">Hello World! –ü—Ä–∏–≤–µ—Ç –º–∏—Ä!</textarea>
            </div>
            <div class="input-group">
                <label for="paddingChar">–°–∏–º–≤–æ–ª –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è:</label>
                <input type="text" id="paddingChar" value="¬∑" maxlength="1" placeholder="–°–∏–º–≤–æ–ª –¥–ª—è –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è">
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="encryptText()" style="background: #ff9900;">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
                <button onclick="decryptText()" style="background: #0099ff;">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>

        <div id="status" class="status warning">–°—Ç–∞—Ç—É—Å: –ë–æ–∫—Å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω</div>

        <div class="result-area">
            <h2>üëÅÔ∏è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞</h2>
            
            <div class="process-step" id="preparationStep">
                <h3>üìã –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞</h3>
                <div id="preparationVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>

            <div class="visualization">
                <div class="vis-box">
                    <h3>üî¢ –í–µ—Ä—Ö–Ω–∏–µ –±–∞–π—Ç—ã (128-255)</h3>
                    <div id="upperBytesVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
                <div class="vis-box">
                    <h3>üî¢ –ù–∏–∂–Ω–∏–µ –±–∞–π—Ç—ã (0-127)</h3>
                    <div id="lowerBytesVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
                </div>
            </div>

            <div class="process-step" id="encryptionStep">
                <h3>üîê –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h3>
                <div id="encryptionVis">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>

            <div class="process-step" id="resultStep">
                <h3>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç</h3>
                <div class="input-group">
                    <label for="encryptedText">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (HEX):</label>
                    <textarea id="encryptedText" placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ HEX..."></textarea>
                </div>
                <div class="hex-view" id="hexView">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
            </div>
            
            <h3>üìã –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π</h3>
            <div class="hex-view" id="history">–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π...</div>
        </div>
    </div>

    <script>
        class OmoCipher {
            constructor() {
                this.box = null;
                this.reverseMap = null;
                this.isInitialized = false;
            }

            async initialize(passphrase, saltHex) {
                const salt = this.hexToBytes(saltHex);
                const keyMaterial = await crypto.subtle.importKey(
                    'raw', new TextEncoder().encode(passphrase), 'PBKDF2', false, ['deriveBits']
                );
                
                const derivedKey = await crypto.subtle.deriveBits(
                    { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
                    keyMaterial, 256
                );

                await this.createBox(new Uint8Array(derivedKey));
                this.isInitialized = true;
            }

            async createBox(key) {
                this.box = new Array(256);
                this.reverseMap = new Map();
                
                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω (128-255 –¥–ª—è X, 0-127 –¥–ª—è Y)
                for (let x = 128; x < 256; x++) {
                    this.box[x] = new Array(128);
                    for (let y = 0; y < 128; y++) {
                        // 4 –æ–º–æ—Ñ–æ–Ω–∞ –≤ –∫–∞–∂–¥–æ–π —è—á–µ–π–∫–µ
                        this.box[x][y] = [
                            this.generateOmo—Ñ–æ–Ω(x, y, 0, key),
                            this.generateOmo—Ñ–æ–Ω(x, y, 1, key),
                            this.generateOmo—Ñ–æ–Ω(x, y, 2, key),
                            this.generateOmo—Ñ–æ–Ω(x, y, 3, key)
                        ];
                        
                        // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é –∫–∞—Ä—Ç—É
                        this.box[x][y].forEach(omo—Ñ–æ–Ω => {
                            this.reverseMap.set(omo—Ñ–æ–Ω, { x, y });
                        });
                    }
                }
            }

            generateOmo—Ñ–æ–Ω(x, y, index, key) {
                const data = new TextEncoder().encode(`${x}-${y}-${index}`);
                let hash = 0;
                
                for (let i = 0; i < data.length; i++) {
                    hash = ((hash << 5) - hash) + data[i];
                    hash |= 0;
                }
                
                for (let i = 0; i < key.length; i++) {
                    hash = ((hash << 3) - hash) + key[i];
                    hash |= 0;
                }
                
                return Math.abs(hash) % 65536;
            }

            encrypt(x, y) {
                if (!this.isValidCoord(x, y)) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã');
                const omophones = this.box[x][y];
                const randomIndex = Math.floor(Math.random() * 4);
                return {
                    value: omophones[randomIndex],
                    index: randomIndex,
                    x, y
                };
            }

            decrypt(omo—Ñ–æ–Ω) {
                const coords = this.reverseMap.get(omo—Ñ–æ–Ω);
                if (!coords) throw new Error('–û–º–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return coords;
            }

            isValidCoord(x, y) {
                return x >= 128 && x <= 255 && y >= 0 && y <= 127;
            }

            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i/2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes;
            }

            bytesToHex(bytes) {
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
            }

            prepareText(text, paddingChar = '¬∑') {
                const bytes = new TextEncoder().encode(text);
                const upperBytes = [];
                const lowerBytes = [];
                
                // –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –≤–µ—Ä—Ö–Ω–∏–µ –∏ –Ω–∏–∂–Ω–∏–µ –±–∞–π—Ç—ã
                for (let i = 0; i < bytes.length; i++) {
                    if (i % 2 === 0) {
                        upperBytes.push(bytes[i]);
                    } else {
                        lowerBytes.push(bytes[i]);
                    }
                }
                
                // –î–æ–±–∞–≤–ª—è–µ–º padding –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                if (upperBytes.length > lowerBytes.length) {
                    const paddingByte = new TextEncoder().encode(paddingChar)[0];
                    lowerBytes.push(paddingByte);
                }
                
                return { upperBytes, lowerBytes, originalLength: bytes.length };
            }

            reconstructText(upperBytes, lowerBytes, originalLength, paddingChar = '¬∑') {
                const bytes = new Uint8Array(originalLength);
                const paddingByte = new TextEncoder().encode(paddingChar)[0];
                
                for (let i = 0; i < originalLength; i++) {
                    if (i % 2 === 0) {
                        bytes[i] = upperBytes[Math.floor(i / 2)];
                    } else {
                        bytes[i] = lowerBytes[Math.floor(i / 2)];
                    }
                }
                
                // –£–±–∏—Ä–∞–µ–º padding
                let text = new TextDecoder().decode(bytes);
                if (text.endsWith(paddingChar)) {
                    text = text.slice(0, -1);
                }
                
                return text;
            }
        }

        const cipher = new OmoCipher();
        let operationHistory = [];
        let currentUpperBytes = [];
        let currentLowerBytes = [];
        let currentOriginalLength = 0;

        async function initializeBox() {
            const passphrase = document.getElementById('passphrase').value;
            const salt = document.getElementById('salt').value;
            
            try {
                updateStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ–∫—Å–∞...', 'warning');
                await cipher.initialize(passphrase, salt);
                updateStatus('–ë–æ–∫—Å —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!', 'success');
                addToHistory('–°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Å –Ω–æ–≤—ã–º –∫–ª—é—á–æ–º');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message, 'error');
            }
        }

        function encryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å!', 'error');
                return;
            }

            const text = document.getElementById('inputText').value;
            const paddingChar = document.getElementById('paddingChar').value || '¬∑';
            
            if (!text) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞
                const preparation = cipher.prepareText(text, paddingChar);
                currentUpperBytes = preparation.upperBytes;
                currentLowerBytes = preparation.lowerBytes;
                currentOriginalLength = preparation.originalLength;

                // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏
                let prepHtml = `
                    <div>–ò—Å—Ö–æ–¥–Ω–∞—è –¥–ª–∏–Ω–∞: ${preparation.originalLength} –±–∞–π—Ç</div>
                    <div>–í–µ—Ä—Ö–Ω–∏—Ö –±–∞–π—Ç–æ–≤: ${preparation.upperBytes.length}</div>
                    <div>–ù–∏–∂–Ω–∏—Ö –±–∞–π—Ç–æ–≤: ${preparation.lowerBytes.length}</div>
                `;
                
                if (preparation.upperBytes.length !== preparation.lowerBytes.length) {
                    prepHtml += `<div>–î–æ–±–∞–≤–ª–µ–Ω padding: "${paddingChar}"</div>`;
                }
                
                document.getElementById('preparationVis').innerHTML = prepHtml;

                // 2. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–π—Ç–æ–≤
                let upperHtml = '';
                let lowerHtml = '';
                
                preparation.upperBytes.forEach((byte, index) => {
                    upperHtml += `<div class="byte-pair">
                        <span>–ë–∞–π—Ç ${index}:</span>
                        <span>${byte} (0x${byte.toString(16).padStart(2, '0')})</span>
                    </div>`;
                });
                
                preparation.lowerBytes.forEach((byte, index) => {
                    lowerHtml += `<div class="byte-pair">
                        <span>–ë–∞–π—Ç ${index}:</span>
                        <span>${byte} (0x${byte.toString(16).padStart(2, '0')})</span>
                    </div>`;
                });
                
                document.getElementById('upperBytesVis').innerHTML = upperHtml;
                document.getElementById('lowerBytesVis').innerHTML = lowerHtml;

                // 3. –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
                const encrypted = [];
                let encHtml = '';
                
                for (let i = 0; i < preparation.upperBytes.length; i++) {
                    const upperByte = preparation.upperBytes[i];
                    const lowerByte = preparation.lowerBytes[i];
                    
                    const result = cipher.encrypt(upperByte, lowerByte);
                    encrypted.push(result.value);
                    
                    encHtml += `<div class="byte-pair">
                        <span>(${upperByte},${lowerByte})</span>
                        <span>‚Üí</span>
                        <span>0x${result.value.toString(16).padStart(4, '0')}</span>
                    </div>`;
                }
                
                document.getElementById('encryptionVis').innerHTML = encHtml;
                
                // 4. –†–µ–∑—É–ª—å—Ç–∞—Ç
                const hexOutput = encrypted.map(val => val.toString(16).padStart(4, '0')).join(' ');
                document.getElementById('encryptedText').value = hexOutput;
                document.getElementById('hexView').textContent = `HEX: ${hexOutput}`;
                
                addToHistory(`–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: "${text}" -> ${hexOutput}`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');

            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function decryptText() {
            if (!cipher.isInitialized) {
                updateStatus('–°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –±–æ–∫—Å!', 'error');
                return;
            }

            const hexText = document.getElementById('encryptedText').value;
            const paddingChar = document.getElementById('paddingChar').value || '¬∑';
            
            if (!hexText) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ HEX –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }

            try {
                const hexValues = hexText.trim().split(/\s+/);
                const upperBytes = [];
                const lowerBytes = [];
                let decHtml = '';

                hexValues.forEach(hex => {
                    const value = parseInt(hex, 16);
                    if (isNaN(value)) throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π HEX —Ñ–æ—Ä–º–∞—Ç');
                    
                    const coord = cipher.decrypt(value);
                    upperBytes.push(coord.x);
                    lowerBytes.push(coord.y);
                    
                    decHtml += `<div class="byte-pair">
                        <span>0x${hex.padStart(4, '0')}</span>
                        <span>‚Üí</span>
                        <span>(${coord.x},${coord.y})</span>
                    </div>`;
                });

                document.getElementById('encryptionVis').innerHTML = decHtml;

                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç
                const decryptedText = cipher.reconstructText(upperBytes, lowerBytes, currentOriginalLength, paddingChar);
                document.getElementById('inputText').value = decryptedText;
                
                // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –±–∞–π—Ç–æ–≤
                let upperHtml = '';
                let lowerHtml = '';
                
                upperBytes.forEach((byte, index) => {
                    upperHtml += `<div class="byte-pair">
                        <span>–ë–∞–π—Ç ${index}:</span>
                        <span>${byte} (0x${byte.toString(16).padStart(2, '0')})</span>
                    </div>`;
                });
                
                lowerBytes.forEach((byte, index) => {
                    lowerHtml += `<div class="byte-pair">
                        <span>–ë–∞–π—Ç ${index}:</span>
                        <span>${byte} (0x${byte.toString(16).padStart(2, '0')})</span>
                    </div>`;
                });
                
                document.getElementById('upperBytesVis').innerHTML = upperHtml;
                document.getElementById('lowerBytesVis').innerHTML = lowerHtml;
                
                addToHistory(`–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${hexText} -> "${decryptedText}"`);
                updateStatus('–¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω!', 'success');

            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function addToHistory(message) {
            operationHistory.push(`${new Date().toLocaleTimeString()}: ${message}`);
            if (operationHistory.length > 10) operationHistory.shift();
            document.getElementById('history').textContent = operationHistory.join('\n');
        }

        // –ê–≤—Ç–æ-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', () => {
            setTimeout(initializeBox, 1000);
        });
    </script>
</body>
</html>
