<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoStego — Linux Style</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --linux-bg: #2d2d2d;
            --linux-header-bg: #222222;
            --linux-card-bg: #363636;
            --linux-border: #555555;
            --linux-text: #cccccc;
            --linux-accent: #4a8cbe;
            --linux-accent-hover: #5ba5d6;
            --linux-success: #6ac76a;
            --linux-warning: #d9a85f;
            --linux-error: #d16868;
            --linux-scrollbar: #555555;
            --linux-scrollbar-thumb: #888888;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: 'DejaVu Sans', 'Liberation Sans', 'Ubuntu', sans-serif;
            background-color: var(--linux-bg);
            color: var(--linux-text);
            line-height: 1.5;
            min-height: 100vh;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        /* Заголовок в стиле Linux */
        .linux-header {
            background-color: var(--linux-header-bg);
            padding: 10px 16px;
            border-bottom: 1px solid var(--linux-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .linux-title {
            font-weight: bold;
            font-size: 16px;
        }

        .linux-window-controls {
            display: flex;
            gap: 8px;
        }

        .linux-control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
        }

        .linux-control.close {
            background-color: #ff5f56;
        }

        .linux-control.minimize {
            background-color: #ffbd2e;
        }

        .linux-control.maximize {
            background-color: #27c93f;
        }

        /* Контейнер содержимого */
        .linux-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
        }

        /* Карточки в стиле Linux */
        .linux-card {
            background-color: var(--linux-card-bg);
            border: 1px solid var(--linux-border);
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .linux-card-title {
            font-weight: bold;
            font-size: 15px;
            margin-bottom: 12px;
            color: var(--linux-text);
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--linux-border);
            padding-bottom: 8px;
        }

        .linux-card-title i {
            margin-right: 8px;
            font-size: 14px;
        }

        /* Вкладки в стиле Linux */
        .linux-tabs {
            display: flex;
            border-bottom: 1px solid var(--linux-border);
            margin-bottom: 16px;
        }

        .linux-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            margin-right: 4px;
            background-color: var(--linux-card-bg);
        }

        .linux-tab.active {
            background-color: var(--linux-header-bg);
            border-color: var(--linux-border);
            color: var(--linux-accent);
        }

        /* Элементы форм в стиле Linux */
        .linux-input {
            width: 100%;
            padding: 8px;
            background-color: var(--linux-bg);
            border: 1px solid var(--linux-border);
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--linux-text);
            font-family: inherit;
        }

        .linux-input:focus {
            outline: none;
            border-color: var(--linux-accent);
        }

        .linux-textarea {
            width: 100%;
            min-height: 120px;
            padding: 8px;
            background-color: var(--linux-bg);
            border: 1px solid var(--linux-border);
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 12px;
            resize: vertical;
            color: var(--linux-text);
            font-family: inherit;
        }

        .linux-textarea:focus {
            outline: none;
            border-color: var(--linux-accent);
        }

        .linux-file-input {
            display: none;
        }

        .linux-file-label {
            display: block;
            width: 100%;
            padding: 20px;
            background-color: var(--linux-bg);
            border: 2px dashed var(--linux-border);
            border-radius: 4px;
            text-align: center;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .linux-file-label:hover {
            border-color: var(--linux-accent);
        }

        .linux-file-label i {
            font-size: 24px;
            color: var(--linux-border);
            margin-bottom: 8px;
            display: block;
        }

        .linux-button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: var(--linux-accent);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .linux-button:hover {
            background-color: var(--linux-accent-hover);
        }

        .linux-button.secondary {
            background-color: var(--linux-card-bg);
            color: var(--linux-text);
            border: 1px solid var(--linux-border);
        }

        .linux-button.secondary:hover {
            background-color: var(--linux-bg);
        }

        .linux-button.warning {
            background-color: var(--linux-warning);
        }

        .linux-button.warning:hover {
            background-color: #e0b874;
        }

        /* Прелоадер изображения */
        .linux-image-preview {
            width: 100%;
            height: 200px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
            background-color: var(--linux-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--linux-border);
        }

        .linux-image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* Уведомления */
        .linux-alert {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 12px;
            font-size: 14px;
            display: flex;
            align-items: center;
            border-left: 4px solid;
        }

        .linux-alert i {
            margin-right: 8px;
        }

        .linux-alert.success {
            background-color: rgba(106, 199, 106, 0.15);
            color: var(--linux-success);
            border-left-color: var(--linux-success);
        }

        .linux-alert.error {
            background-color: rgba(209, 104, 104, 0.15);
            color: var(--linux-error);
            border-left-color: var(--linux-error);
        }

        .linux-alert.info {
            background-color: rgba(74, 140, 190, 0.15);
            color: var(--linux-accent);
            border-left-color: var(--linux-accent);
        }

        .linux-alert.warning {
            background-color: rgba(217, 168, 95, 0.15);
            color: var(--linux-warning);
            border-left-color: var(--linux-warning);
        }

        /* Слайдеры */
        .linux-slider-container {
            margin-bottom: 16px;
        }

        .linux-slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--linux-text);
        }

        .linux-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 5px;
            background: var(--linux-border);
            border-radius: 5px;
            outline: none;
        }

        .linux-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--linux-accent);
            cursor: pointer;
            border: 1px solid var(--linux-border);
        }

        /* Переключатели */
        .linux-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .linux-toggle-label {
            font-size: 14px;
        }

        .linux-toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .linux-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .linux-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--linux-border);
            transition: .4s;
            border-radius: 20px;
        }

        .linux-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .linux-toggle-slider {
            background-color: var(--linux-accent);
        }

        input:checked + .linux-toggle-slider:before {
            transform: translateX(20px);
        }

        /* Прогресс-бары */
        .linux-progress-bar {
            width: 100%;
            height: 6px;
            background-color: var(--linux-border);
            border-radius: 3px;
            overflow: hidden;
            margin: 8px 0;
        }

        .linux-progress {
            height: 100%;
            background-color: var(--linux-accent);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Цвета для оценки риска */
        .linux-risk-low {
            color: var(--linux-success);
        }

        .linux-risk-medium {
            color: var(--linux-warning);
        }

        .linux-risk-high {
            color: var(--linux-error);
        }

        /* Содержимое вкладок */
        .linux-tab-content {
            display: none;
        }

        .linux-tab-content.active {
            display: block;
        }

        /* Дополнительный текст */
        .linux-detail-text {
            font-size: 13px;
            color: #999;
            margin-top: 4px;
        }

        /* Списки */
        .linux-list {
            list-style: none;
        }

        .linux-list-item {
            padding: 10px 0;
            border-bottom: 1px solid var(--linux-border);
        }

        .linux-list-item:last-child {
            border-bottom: none;
        }

        /* Бейджи */
        .linux-badge {
            display: inline-block;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 8px;
        }

        .linux-badge.primary {
            background-color: rgba(74, 140, 190, 0.2);
            color: var(--linux-accent);
        }

        .linux-badge.green {
            background-color: rgba(106, 199, 106, 0.2);
            color: var(--linux-success);
        }

        .linux-badge.orange {
            background-color: rgba(217, 168, 95, 0.2);
            color: var(--linux-warning);
        }

        /* Сетка для элементов управления */
        .linux-controls-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        @media (min-width: 768px) {
            .linux-controls-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        /* Рекомендации */
        .linux-recommendation {
            padding: 8px 0;
            color: #999;
            font-size: 13px;
        }

        /* Полоса прокрутки */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--linux-scrollbar);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--linux-scrollbar-thumb);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        /* Анимации */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .fade-in {
            animation: fadeIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .slide-in {
            animation: slideIn 0.3s ease;
        }

        /* Терминальный стиль для текстовых областей */
        .terminal-style {
            background-color: #1e1e1e;
            color: #d0d0d0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="linux-header">
        <div class="linux-title">CryptoStego</div>
        <div class="linux-window-controls">
            <div class="linux-control close"></div>
            <div class="linux-control minimize"></div>
            <div class="linux-control maximize"></div>
        </div>
    </div>

    <div class="linux-container">
        <div class="linux-card">
            <div class="linux-tabs">
                <div class="linux-tab active" data-tab="stegano">Стеганография</div>
                <div class="linux-tab" data-tab="analysis">Анализ</div>
                <div class="linux-tab" data-tab="detection">Обнаружение</div>
            </div>

            <div class="linux-tab-content active" id="stegano-tab">
                <div class="linux-controls-grid">
                    <div class="linux-card">
                        <div class="linux-card-title"><i class="fas fa-lock"></i> Сокрытие сообщения</div>
                        
                        <label class="linux-file-label" for="image-input">
                            <i class="fas fa-cloud-upload-alt"></i>
                            <div>Выберите изображение</div>
                            <div class="linux-detail-text">PNG или JPG, до 10 МБ</div>
                        </label>
                        <input type="file" id="image-input" class="linux-file-input" accept="image/*">
                        
                        <div class="linux-image-preview">
                            <img id="original-image" src="" alt="Оригинальное изображение" style="display: none;">
                            <i class="fas fa-image" style="font-size: 40px; color: #555;"></i>
                        </div>
                        
                        <textarea class="linux-textarea terminal-style" id="message" placeholder="Введите текст для скрытия..."></textarea>
                        
                        <input type="password" class="linux-input terminal-style" id="password" placeholder="Ключ шифрования">
                        
                        <button class="linux-button" id="encode-btn">
                            <i class="fas fa-shield-alt"></i> Скрыть сообщение
                        </button>
                        
                        <button class="linux-button secondary" id="analyze-btn">
                            <i class="fas fa-chart-bar"></i> Анализировать изображение
                        </button>
                        
                        <div id="encode-status" class="linux-alert info" style="display: none;">
                            <i class="fas fa-info-circle"></i> Готов к работе
                        </div>
                    </div>
                    
                    <div class="linux-card">
                        <div class="linux-card-title"><i class="fas fa-unlock"></i> Извлечение сообщения</div>
                        
                        <label class="linux-file-label" for="stego-image-input">
                            <i class="fas fa-file-image"></i>
                            <div>Выберите изображение</div>
                            <div class="linux-detail-text">Содержащее скрытое сообщение</div>
                        </label>
                        <input type="file" id="stego-image-input" class="linux-file-input" accept="image/*">
                        
                        <input type="password" class="linux-input terminal-style" id="decode-password" placeholder="Ключ шифрования">
                        
                        <button class="linux-button" id="decode-btn">
                            <i class="fas fa-search"></i> Извлечь сообщение
                        </button>
                        
                        <textarea class="linux-textarea terminal-style" id="decoded-message" readonly placeholder="Извлеченное сообщение появится здесь"></textarea>
                        
                        <div id="decode-status" class="linux-alert info" style="display: none;">
                            <i class="fas fa-info-circle"></i> Ожидание изображения
                        </div>
                    </div>
                </div>
                
                <div class="linux-card">
                    <div class="linux-card-title"><i class="fas fa-sliders-h"></i> Расширенные настройки</div>
                    
                    <div class="linux-slider-container">
                        <div class="linux-slider-label">
                            <span>Глубина внедрения: <span id="bit-depth-value">1</span> бит</span>
                            <span class="linux-detail-text">Скрытность ↔ Вместимость</span>
                        </div>
                        <input type="range" min="1" max="4" value="1" class="linux-slider" id="bit-depth">
                    </div>
                    
                    <div class="linux-slider-container">
                        <div class="linux-slider-label">
                            <span>Уровень шума: <span id="noise-level-value">10</span>%</span>
                            <span class="linux-detail-text">Маскировка ↔ Качество</span>
                        </div>
                        <input type="range" min="0" max="100" value="10" class="linux-slider" id="noise-level">
                    </div>
                    
                    <div class="linux-toggle">
                        <span class="linux-toggle-label">Адаптивное внедрение</span>
                        <label class="linux-toggle-switch">
                            <input type="checkbox" id="adaptive-embedding" checked>
                            <span class="linux-toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="linux-toggle">
                        <span class="linux-toggle-label">Случайное распределение</span>
                        <label class="linux-toggle-switch">
                            <input type="checkbox" id="random-distribution" checked>
                            <span class="linux-toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div class="linux-toggle">
                        <span class="linux-toggle-label">Защита от анализа</span>
                        <label class="linux-toggle-switch">
                            <input type="checkbox" id="anti-analysis" checked>
                            <span class="linux-toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="linux-tab-content" id="analysis-tab">
                <div class="linux-card">
                    <div class="linux-card-title"><i class="fas fa-shield-alt"></i> Анализ стойкости</div>
                    
                    <label class="linux-file-label" for="analysis-image">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <div>Выберите изображение для анализа</div>
                    </label>
                    <input type="file" id="analysis-image" class="linux-file-input" accept="image/*">
                    
                    <div class="linux-tabs" style="margin-top: 16px;">
                        <div class="linux-tab active" data-analysis="histogram">Гистограммы</div>
                        <div class="linux-tab" data-analysis="chi2">Хи-квадрат</div>
                        <div class="linux-tab" data-analysis="rs">RS-анализ</div>
                        <div class="linux-tab" data-analysis="noise">Шум</div>
                    </div>
                    
                    <button class="linux-button" id="start-analysis">
                        <i class="fas fa-play"></i> Запустить анализ
                    </button>
                    
                    <div class="linux-card-title" style="margin-top: 20px;"><i class="fas fa-chart-line"></i> Результаты анализа</div>
                    
                    <div class="linux-list">
                        <div class="linux-list-item">
                            <div>Обнаружение LSB-внедрения</div>
                            <div class="linux-detail-text">Анализ младших значащих битов</div>
                            <div class="linux-risk-low" id="lsb-result">Не проверено</div>
                            <div class="linux-progress-bar">
                                <div class="linux-progress" id="lsb-progress" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Статистические аномалии</div>
                            <div class="linux-detail-text">Отклонения от нормального распределения</div>
                            <div class="linux-risk-low" id="stats-result">Не проверено</div>
                            <div class="linux-progress-bar">
                                <div class="linux-progress" id="stats-progress" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Анализ гистограммы</div>
                            <div class="linux-detail-text">Распределение цветовых значений</div>
                            <div class="linux-risk-low" id="histogram-result">Не проверено</div>
                            <div class="linux-progress-bar">
                                <div class="linux-progress" id="histogram-progress" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Анализ шумовых характеристик</div>
                            <div class="linux-detail-text">Отклонения в шумовой модели</div>
                            <div class="linux-risk-low" id="noise-result">Не проверено</div>
                            <div class="linux-progress-bar">
                                <div class="linux-progress" id="noise-progress" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Стойкость к атакам</div>
                            <div class="linux-detail-text">Устойчивость к методам обнаружения</div>
                            <div class="linux-risk-low" id="resistance-result">Не проверено</div>
                            <div class="linux-progress-bar">
                                <div class="linux-progress" id="resistance-progress" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="linux-alert info" style="margin-top: 16px;">
                        <i class="fas fa-lightbulb"></i> 
                        <div>Общая оценка стойкости: <span id="overall-score" class="linux-risk-low">Не проверено</span></div>
                        <div class="linux-progress-bar">
                            <div class="linux-progress" id="overall-progress" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div id="recommendations" style="margin-top: 16px;"></div>
                </div>
            </div>
            
            <div class="linux-tab-content" id="detection-tab">
                <div class="linux-card">
                    <div class="linux-card-title"><i class="fas fa-search"></i> Методы обнаружения</div>
                    
                    <div class="linux-list">
                        <div class="linux-list-item">
                            <div>Статистический анализ</div>
                            <div class="linux-detail-text">Выявление аномалии в распределении значений пикселей</div>
                            <span class="linux-badge primary">Высокая точность</span>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Анализ гистограмм</div>
                            <div class="linux-detail-text">Сравнение распределения цветовых характеристик</div>
                            <span class="linux-badge green">Для LSB</span>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Хи-квадрат тест</div>
                            <div class="linux-detail-text">Обнаружение LSB-стеганографии по равномерности пар значений</div>
                            <span class="linux-badge orange">Средняя точность</span>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>RS-анализ</div>
                            <div class="linux-detail-text">Классификация групп пикселей и анализ их регулярности</div>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Анализ шумовых характеристик</div>
                            <div class="linux-detail-text">Исследование уровня шума и выявление аномалий</div>
                        </div>
                        
                        <div class="linux-list-item">
                            <div>Машинное обучение</div>
                            <div class="linux-detail-text">Использование обученных классификаторов для обнаружения</div>
                            <span class="linux-badge primary">Современный метод</span>
                        </div>
                    </div>
                </div>
                
                <div class="linux-card">
                    <div class="linux-card-title"><i class="fas fa-lightbulb"></i> Рекомендации по скрытности</div>
                    
                    <div class="linux-list">
                        <div class="linux-list-item">
                            <i class="fas fa-check-circle" style="color: var(--linux-success); margin-right: 10px;"></i>
                            <div>Используйте адаптивные методы внедрения</div>
                        </div>
                        
                        <div class="linux-list-item">
                            <i class="fas fa-check-circle" style="color: var(--linux-success); margin-right: 10px;"></i>
                            <div>Ограничивайте объем данных (5-10% от емкости)</div>
                        </div>
                        
                        <div class="linux-list-item">
                            <i class="fas fa-check-circle" style="color: var(--linux-success); margin-right: 10px;"></i>
                            <div>Применяйте криптографическое преобразование</div>
                        </div>
                        
                        <div class="linux-list-item">
                            <i class="fas fa-check-circle" style="color: var(--linux-success); margin-right: 10px;"></i>
                            <div>Используйте текстурные области для внедрения</div>
                        </div>
                        
                        <div class="linux-list-item">
                            <i class="fas fa-check-circle" style="color: var(--linux-success); margin-right: 10px;"></i>
                            <div>Сохраняйте статистические характеристики</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Инициализация приложения
        document.addEventListener('DOMContentLoaded', function() {
            // Управление табами
            const tabs = document.querySelectorAll('.linux-tab');
            const tabContents = document.querySelectorAll('.linux-tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    
                    // Активируем выбранную вкладку
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
            
            // Управление типами анализа
            const analysisTabs = document.querySelectorAll('[data-analysis]');
            analysisTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    analysisTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                });
            });
            
            // Обновление значений слайдеров
            const bitDepthSlider = document.getElementById('bit-depth');
            const bitDepthValue = document.getElementById('bit-depth-value');
            const noiseLevelSlider = document.getElementById('noise-level');
            const noiseLevelValue = document.getElementById('noise-level-value');
            
            bitDepthSlider.addEventListener('input', function() {
                bitDepthValue.textContent = this.value;
            });
            
            noiseLevelSlider.addEventListener('input', function() {
                noiseLevelValue.textContent = this.value;
            });
            
            // Обработка выбора файлов
            const fileInputs = document.querySelectorAll('.linux-file-input');
            fileInputs.forEach(input => {
                const label = input.previousElementSibling;
                
                input.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        label.querySelector('div').textContent = file.name;
                        
                        // Если это изображение, показываем превью
                        if (input.id === 'image-input' || input.id === 'stego-image-input') {
                            const reader = new FileReader();
                            reader.onload = function(event) {
                                const img = document.getElementById(input.id === 'image-input' ? 'original-image' : 'stego-image');
                                if (!img) {
                                    const newImg = document.createElement('img');
                                    newImg.id = input.id === 'image-input' ? 'original-image' : 'stego-image';
                                    newImg.src = event.target.result;
                                    newImg.alt = "Загруженное изображение";
                                    newImg.style.display = 'block';
                                    label.nextElementSibling.appendChild(newImg);
                                } else {
                                    img.src = event.target.result;
                                    img.style.display = 'block';
                                }
                                
                                // Скрываем иконку placeholder
                                const placeholderIcon = label.nextElementSibling.querySelector('i');
                                if (placeholderIcon) {
                                    placeholderIcon.style.display = 'none';
                                }
                            };
                            reader.readAsDataURL(file);
                        }
                    }
                });
            });
            
            // Кодирование сообщения в изображение
            document.getElementById('encode-btn').addEventListener('click', async function() {
                const imageInput = document.getElementById('image-input');
                const messageInput = document.getElementById('message');
                const passwordInput = document.getElementById('password');
                const status = document.getElementById('encode-status');
                
                if (!imageInput.files[0]) {
                    status.style.display = 'flex';
                    status.className = 'linux-alert error';
                    status.innerHTML = '<i class="fas fa-exclamation-circle"></i> Выберите изображение';
                    return;
                }
                
                if (!messageInput.value) {
                    status.style.display = 'flex';
                    status.className = 'linux-alert error';
                    status.innerHTML = '<i class="fas fa-exclamation-circle"></i> Введите сообщение';
                    return;
                }
                
                if (!passwordInput.value) {
                    status.style.display = 'flex';
                    status.className = 'linux-alert error';
                    status.innerHTML = '<i class="fas fa-exclamation-circle"></i> Введите ключ шифрования';
                    return;
                }
                
                status.style.display = 'flex';
                status.className = 'linux-alert info';
                status.innerHTML = '<i class="fas fa-sync fa-spin"></i> Идет процесс скрытия сообщения...';
                
                try {
                    // Получаем настройки
                    const bitsPerChannel = parseInt(bitDepthSlider.value);
                    const noiseLevel = parseInt(noiseLevelSlider.value) / 100;
                    const useAdaptive = document.getElementById('adaptive-embedding').checked;
                    const useRandom = document.getElementById('random-distribution').checked;
                    const useAntiAnalysis = document.getElementById('anti-analysis').checked;
                    
                    // Загружаем изображение
                    const imageFile = imageInput.files[0];
                    const imageData = await loadImageData(imageFile);
                    
                    // Шифруем сообщение
                    const encryptedMessage = await encryptMessage(messageInput.value, passwordInput.value);
                    
                    // Преобразуем сообщение в битовый массив
                    const messageBits = [];
                    for (let byte of encryptedMessage) {
                        for (let i = 7; i >= 0; i--) {
                            messageBits.push((byte >> i) & 1);
                        }
                    }
                    
                    // Добавляем маркер конца сообщения
                    for (let i = 0; i < 32; i++) {
                        messageBits.push(0);
                    }
                    
                    // Генерируем позиции для внедрения
                    const positions = generatePositions(imageData, messageBits.length, useRandom ? passwordInput.value : null);
                    
                    // Анализируем текстуру изображения (если включено адаптивное внедрение)
                    let textureMap = null;
                    if (useAdaptive) {
                        textureMap = analyzeTexture(imageData);
                    }
                    
                    // Встраиваем сообщение
                    embedMessage(imageData, messageBits, positions, bitsPerChannel, textureMap);
                    
                    // Добавляем маскирующий шум
                    if (noiseLevel > 0) {
                        addNoise(imageData, noiseLevel, textureMap);
                    }
                    
                    // Применяем защиту от стегоанализа
                    if (useAntiAnalysis) {
                        applyAntiAnalysis(imageData, textureMap);
                    }
                    
                    // Сохраняем результат
                    const resultImage = await saveImageData(imageData);
                    const link = document.createElement('a');
                    link.download = 'secure-stego-image.png';
                    link.href = resultImage;
                    link.click();
                    
                    status.className = 'linux-alert success';
                    status.innerHTML = '<i class="fas fa-check-circle"></i> Сообщение успешно скрыто! Файл сохранен.';
                } catch (error) {
                    status.className = 'linux-alert error';
                    status.innerHTML = `<i class="fas fa-exclamation-circle"></i> Ошибка: ${error.message}`;
                }
            });
            
            // Декодирование сообщения из изображения
            document.getElementById('decode-btn').addEventListener('click', async function() {
                const imageInput = document.getElementById('stego-image-input');
                const passwordInput = document.getElementById('decode-password');
                const status = document.getElementById('decode-status');
                
                if (!imageInput.files[0]) {
                    status.style.display = 'flex';
                    status.className = 'linux-alert error';
                    status.innerHTML = '<i class="fas fa-exclamation-circle"></i> Выберите изображение';
                    return;
                }
                
                if (!passwordInput.value) {
                    status.style.display = 'flex';
                    status.className = 'linux-alert error';
                    status.innerHTML = '<i class="fas fa-exclamation-circle"></i> Введите ключ шифрования';
                    return;
                }
                
                status.style.display = 'flex';
                status.className = 'linux-alert info';
                status.innerHTML = '<i class="fas fa-sync fa-spin"></i> Идет процесс извлечения сообщения...';
                
                try {
                    // Получаем настройки
                    const bitsPerChannel = parseInt(bitDepthSlider.value);
                    const useRandom = document.getElementById('random-distribution').checked;
                    
                    // Загружаем изображение
                    const imageFile = imageInput.files[0];
                    const imageData = await loadImageData(imageFile);
                    
                    // Генерируем позиции для извлечения (оцениваем максимально возможное количество)
                    const estimatedBits = imageData.width * imageData.height * 3 * bitsPerChannel;
                    const positions = generatePositions(imageData, estimatedBits, useRandom ? passwordInput.value : null);
                    
                    // Извлекаем биты
                    const extractedBits = extractBits(imageData, positions, bitsPerChannel);
                    
                    // Ищем маркер конца сообщения
                    let endIndex = -1;
                    for (let i = 0; i < extractedBits.length - 31; i++) {
                        if (extractedBits.slice(i, i + 32).every(bit => bit === 0)) {
                            endIndex = i;
                            break;
                        }
                    }
                    
                    if (endIndex === -1) {
                        throw new Error('Не удалось найти конец сообщения. Возможно, неверный ключ.');
                    }
                    
                    // Обрезаем биты до конца сообщения
                    const messageBits = extractedBits.slice(0, endIndex);
                    
                    // Конвертируем биты в байты
                    const bytes = [];
                    for (let i = 0; i < messageBits.length; i += 8) {
                        if (i + 8 > messageBits.length) break;
                        
                        let byte = 0;
                        for (let j = 0; j < 8; j++) {
                            byte = (byte << 1) | messageBits[i + j];
                        }
                        bytes.push(byte);
                    }
                    
                    // Дешифруем сообщение
                    const decryptedMessage = await decryptMessage(bytes, passwordInput.value);
                    document.getElementById('decoded-message').value = decryptedMessage;
                    
                    status.className = 'linux-alert success';
                    status.innerHTML = '<i class="fas fa-check-circle"></i> Сообщение успешно извлечено!';
                } catch (error) {
                    status.className = 'linux-alert error';
                    status.innerHTML = `<i class="fas fa-exclamation-circle"></i> Ошибка: ${error.message}`;
                }
            });
            
            // Анализ изображения
            document.getElementById('analyze-btn').addEventListener('click', async function() {
                const imageInput = document.getElementById('image-input');
                const status = document.getElementById('encode-status');
                
                if (!imageInput.files[0]) {
                    status.style.display = 'flex';
                    status.className = 'linux-alert error';
                    status.innerHTML = '<i class="fas fa-exclamation-circle"></i> Выберите изображение';
                    return;
                }
                
                status.style.display = 'flex';
                status.className = 'linux-alert info';
                status.innerHTML = '<i class="fas fa-sync fa-spin"></i> Анализирую текстуру изображения...';
                
                try {
                    // Загружаем изображение
                    const imageFile = imageInput.files[0];
                    const imageData = await loadImageData(imageFile);
                    
                    // Анализируем текстуру
                    const textureMap = analyzeTexture(imageData);
                    
                    // Визуализируем результат
                    const textureCanvas = document.createElement('canvas');
                    textureCanvas.width = imageData.width;
                    textureCanvas.height = imageData.height;
                    const textureCtx = textureCanvas.getContext('2d');
                    const textureImageData = textureCtx.createImageData(imageData.width, imageData.height);
                    
                    for (let i = 0; i < textureMap.length; i++) {
                        const value = textureMap[i];
                        textureImageData.data[i * 4] = value;     // R
                        textureImageData.data[i * 4 + 1] = value; // G
                        textureImageData.data[i * 4 + 2] = value; // B
                        textureImageData.data[i * 4 + 3] = 255;   // A
                    }
                    
                    textureCtx.putImageData(textureImageData, 0, 0);
                    document.getElementById('original-image').src = textureCanvas.toDataURL();
                    
                    status.className = 'linux-alert success';
                    status.innerHTML = '<i class="fas fa-check-circle"></i> Анализ завершен. Светлые области лучше подходят для внедрения.';
                } catch (error) {
                    status.className = 'linux-alert error';
                    status.innerHTML = `<i class="fas fa-exclamation-circle"></i> Ошибка: ${error.message}`;
                }
            });
            
            // Анализ стойкости
            document.getElementById('start-analysis').addEventListener('click', async function() {
                const imageInput = document.getElementById('analysis-image');
                
                if (!imageInput.files[0]) {
                    alert('Сначала выберите изображение для анализа');
                    return;
                }
                
                try {
                    // Загружаем изображение
                    const imageFile = imageInput.files[0];
                    const imageData = await loadImageData(imageFile);
                    
                    // Запускаем анализ
                    analyzeSteganoStrength(imageData);
                } catch (error) {
                    console.error('Ошибка анализа:', error);
                }
            });
            
            // Профессиональные функции стеганографии
            
            async function loadImageData(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        resolve(imageData);
                    };
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }
            
            async function saveImageData(imageData) {
                const canvas = document.createElement('canvas');
                canvas.width = imageData.width;
                canvas.height = imageData.height;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL('image/png');
            }
            
            function generatePositions(imageData, length, seed) {
                const positions = [];
                const totalPixels = imageData.width * imageData.height;
                
                if (seed) {
                    // Детерминированная последовательность на основе seed
                    let counter = 0;
                    const usedPositions = new Set();
                    
                    while (positions.length < Math.min(length, totalPixels)) {
                        // Генерируем хеш на основе seed и счетчика
                        const hash = simpleHash(seed + counter.toString());
                        const position = Math.abs(hash) % totalPixels;
                        
                        if (!usedPositions.has(position)) {
                            positions.push(position);
                            usedPositions.add(position);
                        }
                        
                        counter++;
                        // Защита от бесконечного цикла - ограничиваем максимальным количеством пикселей
                        if (counter > totalPixels * 2) break;
                    }
                } else {
                    // Последовательное распределение
                    const maxPositions = Math.min(length, totalPixels);
                    for (let i = 0; i < maxPositions; i++) {
                        positions.push(i % totalPixels);
                    }
                }
                
                return positions;
            }
            
            function simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0; // Convert to 32bit integer
                }
                return hash;
            }
            
            function analyzeTexture(imageData) {
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;
                const textureMap = new Uint8Array(width * height);
                
                // Простой анализ текстуры на основе вариации интенсивности
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let variance = 0;
                        let centerIdx = (y * width + x) * 4;
                        let centerValue = (data[centerIdx] + data[centerIdx+1] + data[centerIdx+2]) / 3;
                        
                        // Проверяем 8 соседей
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                
                                const nX = x + dx;
                                const nY = y + dy;
                                
                                if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
                                    const nIdx = (nY * width + nX) * 4;
                                    const nValue = (data[nIdx] + data[nIdx+1] + data[nIdx+2]) / 3;
                                    variance += Math.abs(nValue - centerValue);
                                }
                            }
                        }
                        
                        // Нормализуем variance к 0-255
                        textureMap[y * width + x] = Math.min(255, Math.max(0, variance / 8 * 5));
                    }
                }
                
                return textureMap;
            }
            
            function embedMessage(imageData, messageBits, positions, bitsPerChannel, textureMap) {
                const data = imageData.data;
                const width = imageData.width;
                let bitIndex = 0;
                
                for (let i = 0; i < positions.length && bitIndex < messageBits.length; i++) {
                    const pos = positions[i];
                    const x = pos % width;
                    const y = Math.floor(pos / width);
                    const pixelIndex = (y * width + x) * 4;
                    
                    // Пропускаем прозрачность (альфа-канал)
                    for (let channel = 0; channel < 3 && bitIndex < messageBits.length; channel++) {
                        // Определяем, встраиваем ли мы в этот пиксель (для адаптивного режима)
                        let shouldEmbed = true;
                        let embedStrength = bitsPerChannel;
                        
                        if (textureMap) {
                            const textureValue = textureMap[y * width + x];
                            shouldEmbed = textureValue > 128; // Встраиваем только в текстурные области
                            
                            // Регулируем глубину внедрения в зависимости от текстурности
                            if (shouldEmbed) {
                                embedStrength = Math.min(4, Math.max(1, Math.floor(textureValue / 64)));
                            }
                        }
                        
                        if (shouldEmbed) {
                            // Встраиваем несколько бит в канал
                            let channelValue = data[pixelIndex + channel];
                            for (let bit = 0; bit < embedStrength && bitIndex < messageBits.length; bit++) {
                                const bitMask = 1 << bit;
                                channelValue = (channelValue & ~bitMask) | (messageBits[bitIndex++] << bit);
                            }
                            data[pixelIndex + channel] = channelValue;
                        }
                    }
                }
            }
            
            function extractBits(imageData, positions, bitsPerChannel) {
                const data = imageData.data;
                const width = imageData.width;
                const extractedBits = [];
                
                // Извлекаем биты в правильном порядке
                for (let i = 0; i < positions.length; i++) {
                    const pos = positions[i];
                    const x = pos % width;
                    const y = Math.floor(pos / width);
                    const pixelIndex = (y * width + x) * 4;
                    
                    for (let channel = 0; channel < 3; channel++) {
                        const channelValue = data[pixelIndex + channel];
                        for (let bit = 0; bit < bitsPerChannel; bit++) {
                            const bitValue = (channelValue >> bit) & 1;
                            extractedBits.push(bitValue);
                        }
                    }
                    
                    // Проверяем на окончание сообщения (32 нулевых бита)
                    if (extractedBits.length >= 32) {
                        const last32Bits = extractedBits.slice(-32);
                        if (last32Bits.every(bit => bit === 0)) {
                            return extractedBits.slice(0, -32); // Убираем маркер конца
                        }
                    }
                }
                
                return extractedBits;
            }
            
            function addNoise(imageData, intensity, textureMap) {
                const data = imageData.data;
                const width = imageData.width;
                const noiseIntensity = Math.floor(intensity * 10);
                
                for (let i = 0; i < data.length; i += 4) {
                    const pixelIndex = i / 4;
                    const x = (pixelIndex % width);
                    const y = Math.floor(pixelIndex / width);
                    
                    // Определяем уровень шума на основе текстурности
                    let noiseFactor = 1.0;
                    if (textureMap && textureMap.length > pixelIndex) {
                        // Больше шума в текстурных областях
                        noiseFactor = textureMap[pixelIndex] > 128 ? 1.5 : 0.7;
                    }
                    
                    // Пропускаем альфа-канал
                    for (let j = 0; j < 3; j++) {
                        // Добавляем адаптивный шум в младшие биты
                        if (Math.random() < intensity * noiseFactor) {
                            const noise = Math.floor(Math.random() * noiseIntensity * noiseFactor) - Math.floor(noiseIntensity * noiseFactor / 2);
                            data[i + j] = Math.max(0, Math.min(255, data[i + j] + noise));
                        }
                    }
                }
            }
            
            function applyAntiAnalysis(imageData, textureMap) {
                // Сохранение статистических характеристик изображения
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // 1. Сохранение гистограммы
                preserveHistogram(data);
                
                // 2. Сохранение корреляции между соседними пикселями
                preservePixelCorrelation(data, width, height);
                
                // 3. Маскирование в текстурных областях
                if (textureMap) {
                    enhanceTextureMasking(data, textureMap, width);
                }
            }
            
            function preserveHistogram(data) {
                // Сохранение исходной гистограммы изображения
                const histograms = [
                    new Array(256).fill(0), // R
                    new Array(256).fill(0), // G
                    new Array(256).fill(0)  // B
                ];
                
                // Строим гистограммы
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        histograms[j][data[i + j]]++;
                    }
                }
                
                // Нормализуем гистограммы
                for (let c = 0; c < 3; c++) {
                    const max = Math.max(...histograms[c]);
                    for (let i = 0; i < 256; i++) {
                        histograms[c][i] /= max;
                    }
                }
                
                // Корректируем значения пикселей для сохранения гистограммы
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        const value = data[i + j];
                        const probability = histograms[j][value];
                        
                        // Небольшая корректировка для сохранения статистики
                        if (Math.random() < 0.05) { // 5% пикселей корректируем
                            const adjustment = Math.random() < 0.5 ? -1 : 1;
                            data[i + j] = Math.max(0, Math.min(255, value + adjustment));
                        }
                    }
                }
            }
            
            function preservePixelCorrelation(data, width, height) {
                // Сохранение корреляции между соседними пикселями
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Вычисляем среднее значение соседей
                        let avgR = 0, avgG = 0, avgB = 0;
                        let count = 0;
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                avgR += data[nIdx];
                                avgG += data[nIdx + 1];
                                avgB += data[nIdx + 2];
                                count++;
                            }
                        }
                        
                        avgR /= count;
                        avgG /= count;
                        avgB /= count;
                        
                        // Небольшая корректировка к среднему значению соседей
                        const factor = 0.05;
                        data[idx] = Math.max(0, Math.min(255, data[idx] * (1 - factor) + avgR * factor));
                        data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] * (1 - factor) + avgG * factor));
                        data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] * (1 - factor) + avgB * factor));
                    }
                }
            }
            
            function enhanceTextureMasking(data, textureMap, width) {
                // Усиление маскирования в текстурных областях
                for (let i = 0; i < data.length; i += 4) {
                    const pixelIndex = i / 4;
                    if (textureMap[pixelIndex] > 128) {
                        // В текстурных областях добавляем дополнительный шум
                        for (let j = 0; j < 3; j++) {
                            if (Math.random() < 0.1) {
                                const noise = Math.floor(Math.random() * 5) - 2;
                                data[i + j] = Math.max(0, Math.min(255, data[i + j] + noise));
                            }
                        }
                    }
                }
            }
            
            async function encryptMessage(message, password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                
                // Генерация ключа из пароля с использованием PBKDF2
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                const salt = window.crypto.getRandomValues(new Uint8Array(16));
                const key = await window.crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt']
                );
                
                // Шифрование
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await window.crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128
                    },
                    key,
                    data
                );
                
                // Объединение соли, IV и зашифрованных данных
                const result = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
                result.set(salt, 0);
                result.set(iv, salt.length);
                result.set(new Uint8Array(encrypted), salt.length + iv.length);
                
                return result;
            }
            
            async function decryptMessage(encryptedData, password) {
                try {
                    const encoder = new TextEncoder();
                    
                    // Извлечение соли, IV и зашифрованных данных
                    const salt = encryptedData.slice(0, 16);
                    const iv = encryptedData.slice(16, 28);
                    const data = encryptedData.slice(28);
                    
                    // Генерация ключа из пароля
                    const keyMaterial = await window.crypto.subtle.importKey(
                        'raw',
                        encoder.encode(password),
                        'PBKDF2',
                        false,
                        ['deriveKey']
                    );
                    
                    const key = await window.crypto.subtle.deriveKey(
                        {
                            name: 'PBKDF2',
                            salt: salt,
                            iterations: 100000,
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        { name: 'AES-GCM', length: 256 },
                        false,
                        ['decrypt']
                    );
                    
                    // Дешифрование
                    const decrypted = await window.crypto.subtle.decrypt(
                        {
                            name: 'AES-GCM',
                            iv: iv,
                            tagLength: 128
                        },
                        key,
                        data
                    );
                    
                    return new TextDecoder().decode(decrypted);
                } catch (error) {
                    throw new Error('Неверный ключ или поврежденные данные');
                }
            }
            
            function analyzeSteganoStrength(imageData) {
                // Профессиональная реализация анализа стойкости
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // 1. Расширенный анализ LSB
                const lsbResult = analyzeLSB(data);
                updateAnalysisResult('lsb', lsbResult, 85);
                
                // 2. Статистический анализ с использованием теста хи-квадрат
                const statsResult = analyzeChiSquare(data);
                updateAnalysisResult('stats', statsResult, 75);
                
                // 3. Анализ гистограммы с вычислением энтропии
                const histogramResult = analyzeHistogramEntropy(data);
                updateAnalysisResult('histogram', histogramResult, 65);
                
                // 4. Анализ шума с использованием вейвлет-преобразования
                const noiseResult = analyzeNoisePatterns(data, width, height);
                updateAnalysisResult('noise', noiseResult, 80);
                
                // 5. RS-анализ для обнаружения стеганографии
                const resistanceResult = performRSAnalysis(data, width, height);
                updateAnalysisResult('resistance', resistanceResult, 70);
                
                // Общая оценка
                const overallScore = Math.round((lsbResult + statsResult + histogramResult + noiseResult + resistanceResult) / 5);
                setTimeout(() => {
                    document.getElementById('overall-score').textContent = `${overallScore}%`;
                    document.getElementById('overall-progress').style.width = `${overallScore}%`;
                    
                    if (overallScore >= 80) {
                        document.getElementById('overall-score').className = 'linux-risk-high';
                    } else if (overallScore >= 50) {
                        document.getElementById('overall-score').className = 'linux-risk-medium';
                    } else {
                        document.getElementById('overall-score').className = 'linux-risk-low';
                    }
                    
                    // Рекомендации
                    let recommendations = '';
                    if (overallScore < 40) {
                        recommendations = `
                            <div class="linux-recommendation">Используйте адаптивное внедрение для лучшей маскировки</div>
                            <div class="linux-recommendation">Уменьшите глубину внедрения до 1-2 бит на канал</div>
                            <div class="linux-recommendation">Добавьте маскирующий шум (15-25%)</div>
                            <div class="linux-recommendation">Включите защиту от стегоанализа</div>
                        `;
                    } else if (overallScore < 70) {
                        recommendations = `
                            <div class="linux-recommendation">Используйте случайное распределение данных</div>
                            <div class="linux-recommendation">Добавьте маскирующий шум (10-15%)</div>
                            <div class="linux-recommendation">Ограничьте объем скрываемых данных</div>
                        `;
                    } else {
                        recommendations = `
                            <div class="linux-recommendation">Отличная стойкость! Продолжайте использовать текущие настройки</div>
                            <div class="linux-recommendation">Рассмотрите возможность использования DCT-метода для JPEG</div>
                        `;
                    }
                    
                    document.getElementById('recommendations').innerHTML = recommendations;
                }, 2500);
            }
            
            function analyzeLSB(data) {
                // Профессиональный анализ LSB с использованием нескольких методов
                let sameBits = 0;
                let totalBits = 0;
                let pairs = new Array(4).fill(0).map(() => new Array(4).fill(0));
                
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        const value = data[i + j];
                        const lsb = value & 1;
                        const prevLsb = (value >> 1) & 1;
                        
                        pairs[prevLsb][lsb]++;
                        
                        if (lsb === 0) {
                            sameBits++;
                        }
                        totalBits++;
                    }
                }
                
                // Анализ распределения пар битов
                let pairUniformity = 0;
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        pairUniformity += Math.abs(pairs[i][j] / totalBits - 0.25);
                    }
                }
                
                const deviation = Math.abs(sameBits / totalBits - 0.5);
                const lsbScore = Math.max(0, 100 - Math.round(deviation * 200 * 100));
                const pairScore = Math.max(0, 100 - Math.round(pairUniformity * 400));
                
                return Math.round((lsbScore + pairScore) / 2);
            }
            
            function analyzeChiSquare(data) {
                // Тест хи-квадрат для обнаружения LSB-стеганографии
                const histogram = new Array(128).fill(0);
                
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        const value = data[i + j];
                        const lowerValue = value & 0xFE; // Младший бит обнулен
                        histogram[Math.floor(lowerValue / 2)]++;
                    }
                }
                
                // Вычисляем хи-квадрат
                let chiSquare = 0;
                for (let i = 0; i < 127; i += 2) {
                    const expected = (histogram[i] + histogram[i + 1]) / 2;
                    if (expected > 0) {
                        chiSquare += Math.pow(histogram[i] - expected, 2) / expected;
                        chiSquare += Math.pow(histogram[i + 1] - expected, 2) / expected;
                    }
                }
                
                // Нормализуем результат
                const pValue = 1 - chiSquareCDF(chiSquare, 127);
                return Math.max(0, Math.min(100, Math.round(pValue * 100)));
            }
            
            function chiSquareCDF(x, k) {
                // Approximation of the Chi-Square CDF
                if (x <= 0) return 0;
                if (x > 1000 || k > 1000) return 1;
                
                let sum = 0;
                let term = 1;
                const m = x / 2;
                
                for (let i = 1; i <= k/2; i++) {
                    term *= m / i;
                    sum += term;
                }
                
                return Math.min(1, Math.exp(-m) * sum);
            }
            
            function analyzeHistogramEntropy(data) {
                // Анализ гистограммы с вычислением энтропии
                const histogram = new Array(256).fill(0);
                let total = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    for (let j = 0; j < 3; j++) {
                        histogram[data[i + j]]++;
                        total++;
                    }
                }
                
                // Вычисляем энтропии
                let entropy = 0;
                for (let i = 0; i < 256; i++) {
                    if (histogram[i] > 0) {
                        const p = histogram[i] / total;
                        entropy -= p * Math.log2(p);
                    }
                }
                
                // Нормализуем энтропию (максимальная энтропия для 256 значений = 8)
                const normalizedEntropy = (entropy / 8) * 100;
                
                // Изображения с высокой энтропией более устойчивы к стегоанализу
                return Math.round(normalizedEntropy);
            }
            
            function analyzeNoisePatterns(data, width, height) {
                // Анализ шумовых характеристик с использованием вейвлет-преобразования
                let noiseLevel = 0;
                let sampleCount = 0;
                
                // Простое вейвлет-преобразование (аналог Haar)
                for (let y = 0; y < height - 1; y += 2) {
                    for (let x = 0; x < width - 1; x += 2) {
                        const idx = (y * width + x) * 4;
                        
                        // Вычисляем среднее и разность для 2x2 блока
                        let avgR = 0, avgG = 0, avgB = 0;
                        let diffR = 0, diffG = 0, diffB = 0;
                        
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                avgR += data[nIdx];
                                avgG += data[nIdx + 1];
                                avgB += data[nIdx + 2];
                            }
                        }
                        
                        avgR /= 4; avgG /= 4; avgB /= 4;
                        
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                diffR += Math.abs(data[nIdx] - avgR);
                                diffG += Math.abs(data[nIdx + 1] - avgG);
                                diffB += Math.abs(data[nIdx + 2] - avgB);
                            }
                        }
                        
                        noiseLevel += (diffR + diffG + diffB) / 3;
                        sampleCount++;
                    }
                }
                
                const avgNoise = noiseLevel / sampleCount;
                // Нормализуем результат (эмпирически подобранные значения)
                return Math.max(0, Math.min(100, 100 - (avgNoise - 3) * 10));
            }
            
            function performRSAnalysis(data, width, height) {
                // RS-анализ для обнаружения стеганографии
                let regular = 0;
                let singular = 0;
                let total = 0;
                
                // Анализируем группы пикселей 3x3
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Анализируем только один канал (зеленый) для простоты
                        const center = data[idx + 1];
                        
                        // Соседи
                        const neighbors = [
                            data[((y-1)*width + (x-1))*4 + 1], data[((y-1)*width + x)*4 + 1], data[((y-1)*width + (x+1))*4 + 1],
                            data[(y*width + (x-1))*4 + 1], /* center */ data[(y*width + (x+1))*4 + 1],
                            data[((y+1)*width + (x-1))*4 + 1], data[((y+1)*width + x)*4 + 1], data[((y+1)*width + (x+1))*4 + 1]
                        ];
                        
                        // Вычисляем разности
                        let differences = [];
                        for (let neighbor of neighbors) {
                            differences.push(neighbor - center);
                        }
                        
                        // Классифицируем группу
                        let isRegular = true;
                        let isSingular = true;
                        
                        for (let i = 0; i < differences.length - 1; i++) {
                            if (differences[i] > differences[i + 1]) {
                                isRegular = false;
                            }
                            if (differences[i] < differences[i + 1]) {
                                isSingular = false;
                            }
                        }
                        
                        if (isRegular) regular++;
                        if (isSingular) singular++;
                        total++;
                    }
                }
                
                const ratio = Math.abs(regular - singular) / total;
                return Math.max(0, Math.min(100, 100 - ratio * 1000));
            }
            
            function updateAnalysisResult(type, value, maxValue) {
                const progress = Math.min(value, maxValue);
                const element = document.getElementById(`${type}-result`);
                const progressBar = document.getElementById(`${type}-progress`);
                
                setTimeout(() => {
                    element.textContent = `${value}%`;
                    progressBar.style.width = `${progress}%`;
                    
                    if (value >= 80) {
                        element.className = 'linux-risk-high';
                    } else if (value >= 50) {
                        element.className = 'linux-risk-medium';
                    } else {
                        element.className = 'linux-risk-low';
                    }
                }, 500);
            }
        });
    </script>
</body>
    </html>
